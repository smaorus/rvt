
/*  A Bison parser, made from gram.y
 by  GNU Bison version 1.25
  */

#define YYBISON 1  /* Identify Bison output.  */

#define	IDENT	258
#define	TAG_NAME	259
#define	LABEL_NAME	260
#define	TYPEDEF_NAME	261
#define	STRING	262
#define	LSTRING	263
#define	CHAR_CONST	264
#define	LCHAR_CONST	265
#define	INUM	266
#define	RNUM	267
#define	PP_LINE	268
#define	INVALID	269
#define	CONST	270
#define	VOLATILE	271
#define	AUTO	272
#define	EXTRN	273
#define	REGISTR	274
#define	STATIC	275
#define	TYPEDEF	276
#define	VOID	277
#define	BOOL	278
#define	CHAR	279
#define	SHORT	280
#define	INT	281
#define	INT8	282
#define	INT16	283
#define	INT32	284
#define	INT64	285
#define	LONG	286
#define	FLOAT	287
#define	DOUBLE	288
#define	SGNED	289
#define	UNSGNED	290
#define	ENUM	291
#define	STRUCT	292
#define	UNION	293
#define	BREAK	294
#define	CASE	295
#define	CONT	296
#define	DEFLT	297
#define	DO	298
#define	ELSE	299
#define	IF	300
#define	FOR	301
#define	GOTO	302
#define	RETURN	303
#define	SWITCH	304
#define	WHILE	305
#define	PLUS_EQ	306
#define	MINUS_EQ	307
#define	STAR_EQ	308
#define	DIV_EQ	309
#define	MOD_EQ	310
#define	B_AND_EQ	311
#define	B_OR_EQ	312
#define	B_XOR_EQ	313
#define	L_SHIFT_EQ	314
#define	R_SHIFT_EQ	315
#define	EQUAL	316
#define	LESS_EQ	317
#define	GRTR_EQ	318
#define	NOT_EQ	319
#define	RPAREN	320
#define	RBRCKT	321
#define	LBRACE	322
#define	RBRACE	323
#define	SEMICOLON	324
#define	COMMA	325
#define	ELLIPSIS	326
#define	LB_SIGN	327
#define	DOUB_LB_SIGN	328
#define	BACKQUOTE	329
#define	AT	330
#define	ATTRIBUTE	331
#define	ALIGNED	332
#define	PACKED	333
#define	CDECL	334
#define	MODE	335
#define	FORMAT	336
#define	NORETURN	337
#define	MALLOC	338
#define	COMMA_OP	339
#define	EQ	340
#define	ASSIGN	341
#define	QUESTMARK	342
#define	COLON	343
#define	COMMA_SEP	344
#define	OR	345
#define	AND	346
#define	B_OR	347
#define	B_XOR	348
#define	B_AND	349
#define	COMP_EQ	350
#define	COMP_ARITH	351
#define	LESS	352
#define	GRTR	353
#define	L_SHIFT	354
#define	R_SHIFT	355
#define	PLUS	356
#define	MINUS	357
#define	STAR	358
#define	DIV	359
#define	MOD	360
#define	CAST	361
#define	UNARY	362
#define	NOT	363
#define	B_NOT	364
#define	SIZEOF	365
#define	INCR	366
#define	DECR	367
#define	HYPERUNARY	368
#define	ARROW	369
#define	DOT	370
#define	LPAREN	371
#define	LBRCKT	372

#line 1 "gram.y"

 /*
 ======================================================================

    CTool Library
    Copyright (C) 1995-2001	Shaun Flisakowski

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 1, or (at your option)
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

 ======================================================================
 */

/* grammar File for C - Shaun Flisakowski and Patrick Baudin */
/* Grammar was constructed with the assistance of:
    "C - A Reference Manual" (Fourth Edition),
    by Samuel P Harbison, and Guy L Steele Jr. */

#ifdef    NO_ALLOCA
#define   alloca  __builtin_alloca
#endif

#include <stdio.h>
#include <errno.h>
#include <setjmp.h>

#include <ctool/lexer.h>
#include <ctool/symbol.h>
#include <ctool/token.h>
#include <ctool/stemnt.h>
#include <ctool/location.h>
#include <ctool/project.h>

extern int errno;
int yylex(YYSTYPE *lvalp);

/* Cause the `yydebug' variable to be defined.  */
#define YYDEBUG 1

#undef HERE
#define HERE Location(gProject->Parse_TOS->yylineno, \
                      gProject->Parse_TOS->yycolno, \
                      gProject->Parse_TOS->filename)

/*  int  yydebug = 1;  */

/* ###################################################### */
#line 216 "gram.y"

/* 1 if we explained undeclared var errors.  */
/*  static int undeclared_variable_notice = 0;  */
#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		510
#define	YYFLAG		-32768
#define	YYNTBASE	118

#define YYTRANSLATE(x) ((unsigned)(x) <= 372 ? yytranslate[x] : 308)

static const char yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,
    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,
    76,    77,    78,    79,    80,    81,    82,    83,    84,    85,
    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,
    96,    97,    98,    99,   100,   101,   102,   103,   104,   105,
   106,   107,   108,   109,   110,   111,   112,   113,   114,   115,
   116,   117
};

#if YYDEBUG != 0
static const short yyprhs[] = {     0,
     0,     1,     3,     5,     8,    12,    13,    15,    17,    19,
    22,    26,    29,    33,    37,    38,    44,    47,    48,    50,
    52,    55,    58,    60,    65,    68,    69,    71,    73,    76,
    79,    81,    83,    85,    87,    89,    91,    93,    95,    97,
    99,   101,   104,   107,   111,   113,   115,   117,   119,   121,
   127,   130,   133,   137,   141,   143,   149,   157,   165,   171,
   181,   183,   185,   187,   189,   192,   197,   199,   201,   207,
   209,   213,   214,   216,   218,   219,   221,   223,   225,   229,
   231,   235,   238,   240,   244,   246,   250,   252,   256,   259,
   261,   266,   268,   272,   274,   278,   280,   284,   286,   290,
   292,   296,   298,   300,   302,   304,   306,   308,   310,   312,
   314,   316,   321,   324,   327,   330,   333,   336,   339,   342,
   344,   348,   350,   352,   354,   358,   362,   364,   366,   368,
   370,   372,   374,   379,   381,   383,   386,   389,   391,   395,
   399,   404,   405,   407,   409,   413,   415,   417,   419,   421,
   423,   425,   427,   429,   431,   433,   435,   437,   439,   441,
   443,   445,   447,   448,   450,   451,   452,   456,   457,   459,
   460,   461,   465,   468,   472,   475,   478,   481,   484,   485,
   487,   489,   490,   493,   495,   498,   500,   502,   504,   506,
   508,   510,   512,   514,   516,   517,   519,   522,   523,   527,
   530,   531,   533,   534,   538,   541,   543,   544,   548,   550,
   554,   555,   557,   559,   561,   565,   567,   569,   573,   575,
   580,   581,   583,   585,   587,   589,   591,   594,   595,   597,
   599,   601,   603,   605,   607,   609,   611,   613,   615,   617,
   619,   621,   623,   625,   627,   629,   631,   633,   635,   637,
   639,   641,   643,   646,   649,   652,   655,   660,   665,   668,
   673,   678,   681,   686,   691,   692,   694,   695,   698,   699,
   701,   703,   705,   709,   711,   715,   717,   718,   719,   723,
   726,   729,   733,   736,   738,   740,   741,   745,   746,   752,
   754,   756,   758,   759,   764,   766,   767,   769,   771,   773,
   776,   778,   780,   782,   786,   788,   793,   798,   802,   807,
   810,   812,   815,   817,   818,   821,   823,   827,   829,   831,
   833,   835,   836,   837,   840,   841,   844,   846,   850,   852,
   856,   857,   860,   863,   866,   868,   870,   872,   875,   877,
   881,   885,   890,   894,   899,   900,   902,   909,   910,   912,
   914,   916,   918,   923,   928,   937
};

static const short yyrhs[] = {    -1,
   119,     0,     1,     0,   121,   120,     0,   119,   121,   120,
     0,     0,   209,     0,   122,     0,    13,     0,     1,    69,
     0,     1,    68,   120,     0,   123,   124,     0,   213,   279,
   200,     0,   212,   278,   200,     0,     0,    67,   125,   204,
   126,    68,     0,     1,    68,     0,     0,   127,     0,   128,
     0,   127,   128,     0,   127,    13,     0,   132,     0,    67,
   204,   130,    68,     0,     1,    68,     0,     0,   131,     0,
   132,     0,   131,   132,     0,   131,    13,     0,   133,     0,
   134,     0,   129,     0,   135,     0,   136,     0,   137,     0,
   138,     0,   139,     0,   140,     0,   141,     0,   142,     0,
     1,    69,     0,   157,    69,     0,   148,    88,   132,     0,
   143,     0,   144,     0,   145,     0,   146,     0,   147,     0,
    49,   116,   157,    65,   132,     0,    39,    69,     0,    41,
    69,     0,    48,   156,    69,     0,    47,     5,    69,     0,
    69,     0,    45,   116,   157,    65,   132,     0,    45,   116,
   157,    65,   132,    44,   132,     0,    43,   132,    50,   116,
   157,    65,    69,     0,    50,   116,   157,    65,   132,     0,
    46,   116,   156,    69,   156,    69,   156,    65,   132,     0,
   149,     0,   150,     0,   151,     0,   290,     0,    40,   155,
     0,    40,   155,    71,   155,     0,    42,     0,   158,     0,
   158,    87,   157,    88,   152,     0,   152,     0,   171,   198,
   153,     0,     0,   155,     0,   157,     0,     0,   157,     0,
   179,     0,   159,     0,   158,    90,   159,     0,   161,     0,
   159,    91,   161,     0,   108,   165,     0,   162,     0,   161,
    92,   162,     0,   163,     0,   162,    93,   163,     0,   166,
     0,   163,    94,   166,     0,   109,   165,     0,   171,     0,
   116,   215,    65,   165,     0,   167,     0,   166,   195,   167,
     0,   168,     0,   167,   196,   168,     0,   169,     0,   168,
   197,   169,     0,   170,     0,   169,   193,   170,     0,   165,
     0,   170,   194,   165,     0,   182,     0,   172,     0,   173,
     0,   174,     0,   160,     0,   164,     0,   175,     0,   176,
     0,   177,     0,   178,     0,   110,   116,   215,    65,     0,
   110,   171,     0,   102,   165,     0,   101,   165,     0,    94,
   165,     0,   103,   165,     0,   111,   171,     0,   112,   171,
     0,   153,     0,   179,    70,   153,     0,   290,     0,   181,
     0,   199,     0,   116,   157,    65,     0,   116,     1,    65,
     0,   180,     0,   183,     0,   184,     0,   190,     0,   185,
     0,   186,     0,   182,   117,   157,    66,     0,   188,     0,
   189,     0,   182,   111,     0,   182,   112,     0,   292,     0,
   182,   115,   187,     0,   182,   114,   187,     0,   182,   116,
   191,    65,     0,     0,   192,     0,   153,     0,   192,    70,
   153,     0,   101,     0,   102,     0,   103,     0,   104,     0,
   105,     0,    95,     0,    96,     0,    99,     0,   100,     0,
    85,     0,    86,     0,    11,     0,    12,     0,     9,     0,
    10,     0,     7,     0,     8,     0,     0,   201,     0,     0,
     0,   202,   203,   208,     0,     0,   205,     0,     0,     0,
   206,   207,   208,     0,   211,    69,     0,   211,    69,   208,
     0,   210,    69,     0,   211,    69,     0,   212,   233,     0,
   213,   233,     0,     0,   218,     0,   302,     0,     0,   216,
   217,     0,   218,     0,   218,   214,     0,   224,     0,    18,
     0,    20,     0,    21,     0,    17,     0,    19,     0,   219,
     0,   220,     0,   244,     0,     0,   224,     0,   221,   223,
     0,     0,   222,   225,   223,     0,   240,   223,     0,     0,
   227,     0,     0,   244,   228,   226,     0,   240,   226,     0,
   227,     0,     0,   278,   231,   305,     0,   230,     0,   230,
    85,   236,     0,     0,   234,     0,   235,     0,   232,     0,
   235,    70,   232,     0,   238,     0,   238,     0,   237,    70,
   238,     0,   153,     0,    67,   237,   239,    68,     0,     0,
    70,     0,   241,     0,    15,     0,    16,     0,   241,     0,
   242,   241,     0,     0,   242,     0,   255,     0,   251,     0,
   253,     0,   249,     0,   247,     0,   248,     0,   245,     0,
    22,     0,    23,     0,    24,     0,    25,     0,    26,     0,
    27,     0,    28,     0,    29,     0,    30,     0,    31,     0,
    32,     0,    33,     0,    34,     0,    35,     0,     6,     0,
     4,     0,    37,   246,     0,    38,   246,     0,    36,   246,
     0,    37,   246,     0,    37,    67,   256,    68,     0,   250,
    67,   256,    68,     0,    38,   246,     0,    38,    67,   256,
    68,     0,   252,    67,   256,    68,     0,    36,   246,     0,
    36,    67,   257,    68,     0,   254,    67,   257,    68,     0,
     0,   263,     0,     0,   259,   258,     0,     0,    70,     0,
   260,     0,   261,     0,   259,    70,   261,     0,   262,     0,
   262,    85,   153,     0,   292,     0,     0,     0,   264,   265,
   266,     0,   267,    69,     0,   266,    69,     0,   266,   267,
    69,     0,   229,   268,     0,   229,     0,   269,     0,     0,
   270,   272,   305,     0,     0,   269,    70,   271,   272,   305,
     0,   273,     0,   274,     0,   278,     0,     0,   277,    88,
   275,   276,     0,   152,     0,     0,   278,     0,   280,     0,
   280,     0,   286,   281,     0,   281,     0,   282,     0,   290,
     0,   116,   280,    65,     0,   283,     0,   282,   116,   295,
    65,     0,   282,   116,   287,    65,     0,   282,   116,    65,
     0,   282,   117,   154,    66,     0,   103,   243,     0,   284,
     0,   285,   284,     0,   285,     0,     0,   288,   289,     0,
   290,     0,   289,    70,   290,     0,     3,     0,     6,     0,
   290,     0,   291,     0,     0,     0,   294,   297,     0,     0,
   296,   297,     0,   298,     0,   298,    70,    71,     0,   299,
     0,   298,    70,   299,     0,     0,   300,   301,     0,   218,
   278,     0,   218,   302,     0,   218,     0,   286,     0,   303,
     0,   286,   303,     0,   304,     0,   116,   302,    65,     0,
   117,   154,    66,     0,   304,   117,   154,    66,     0,   116,
   293,    65,     0,   304,   116,   293,    65,     0,     0,   306,
     0,    76,   116,   116,   307,    65,    65,     0,     0,    78,
     0,    79,     0,    15,     0,    82,     0,    77,   116,    11,
    65,     0,    80,   116,   290,    65,     0,    81,   116,   290,
    70,    11,    70,    11,    65,     0,    83,     0
};

#endif

#if YYDEBUG != 0
static const short yyrline[] = { 0,
   227,   235,   246,   254,   259,   265,   274,   278,   282,   286,
   290,   296,   324,   353,   386,   391,   404,   410,   414,   417,
   418,   427,   442,   445,   455,   461,   465,   468,   469,   478,
   489,   490,   491,   492,   493,   494,   495,   496,   497,   498,
   499,   500,   507,   514,   530,   531,   534,   535,   536,   539,
   548,   556,   564,   572,   580,   587,   596,   606,   617,   626,
   638,   639,   640,   643,   651,   656,   664,   680,   681,   689,
   690,   696,   700,   703,   706,   710,   713,   716,   717,   724,
   725,   732,   739,   740,   747,   748,   755,   756,   763,   770,
   771,   779,   780,   786,   787,   793,   794,   800,   801,   807,
   808,   814,   815,   816,   817,   818,   819,   820,   821,   822,
   823,   826,   833,   840,   846,   853,   860,   866,   873,   880,
   881,   888,   897,   898,   904,   910,   918,   919,   920,   921,
   922,   923,   926,   934,   935,   938,   945,   952,   955,   978,
  1001,  1014,  1018,  1021,  1022,  1031,  1032,  1035,  1036,  1037,
  1040,  1043,  1046,  1047,  1050,  1051,  1054,  1055,  1056,  1057,
  1058,  1059,  1067,  1073,  1078,  1084,  1088,  1099,  1106,  1109,
  1115,  1118,  1123,  1128,  1141,  1147,  1156,  1174,  1194,  1201,
  1210,  1213,  1219,  1225,  1235,  1263,  1269,  1270,  1271,  1274,
  1275,  1278,  1279,  1289,  1292,  1296,  1299,  1318,  1319,  1350,
  1370,  1374,  1377,  1378,  1387,  1402,  1411,  1416,  1422,  1423,
  1430,  1434,  1437,  1440,  1444,  1460,  1462,  1467,  1475,  1476,
  1484,  1488,  1500,  1503,  1504,  1507,  1508,  1516,  1520,  1527,
  1528,  1529,  1530,  1531,  1532,  1533,  1534,  1535,  1536,  1537,
  1538,  1539,  1540,  1541,  1542,  1543,  1544,  1545,  1546,  1547,
  1550,  1557,  1565,  1575,  1585,  1595,  1605,  1612,  1636,  1646,
  1654,  1679,  1689,  1696,  1719,  1723,  1726,  1730,  1735,  1739,
  1749,  1752,  1757,  1765,  1780,  1797,  1803,  1809,  1815,  1823,
  1829,  1837,  1845,  1850,  1861,  1864,  1867,  1872,  1875,  1884,
  1902,  1919,  1922,  1926,  1942,  1945,  1949,  1956,  1962,  1968,
  1973,  1976,  1979,  1984,  1990,  1991,  2008,  2025,  2050,  2068,
  2074,  2075,  2082,  2088,  2095,  2104,  2109,  2121,  2125,  2137,
  2138,  2146,  2150,  2154,  2159,  2166,  2173,  2174,  2183,  2184,
  2191,  2196,  2202,  2224,  2247,  2261,  2265,  2269,  2276,  2279,
  2283,  2287,  2298,  2302,  2319,  2323,  2326,  2336,  2341,  2345,
  2349,  2353,  2357,  2371,  2380,  2403
};
#endif


#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)

static const char * const yytname[] = {   "$","error","$undefined.","IDENT",
"TAG_NAME","LABEL_NAME","TYPEDEF_NAME","STRING","LSTRING","CHAR_CONST","LCHAR_CONST",
"INUM","RNUM","PP_LINE","INVALID","CONST","VOLATILE","AUTO","EXTRN","REGISTR",
"STATIC","TYPEDEF","VOID","BOOL","CHAR","SHORT","INT","INT8","INT16","INT32",
"INT64","LONG","FLOAT","DOUBLE","SGNED","UNSGNED","ENUM","STRUCT","UNION","BREAK",
"CASE","CONT","DEFLT","DO","ELSE","IF","FOR","GOTO","RETURN","SWITCH","WHILE",
"PLUS_EQ","MINUS_EQ","STAR_EQ","DIV_EQ","MOD_EQ","B_AND_EQ","B_OR_EQ","B_XOR_EQ",
"L_SHIFT_EQ","R_SHIFT_EQ","EQUAL","LESS_EQ","GRTR_EQ","NOT_EQ","RPAREN","RBRCKT",
"LBRACE","RBRACE","SEMICOLON","COMMA","ELLIPSIS","LB_SIGN","DOUB_LB_SIGN","BACKQUOTE",
"AT","ATTRIBUTE","ALIGNED","PACKED","CDECL","MODE","FORMAT","NORETURN","MALLOC",
"COMMA_OP","EQ","ASSIGN","QUESTMARK","COLON","COMMA_SEP","OR","AND","B_OR","B_XOR",
"B_AND","COMP_EQ","COMP_ARITH","LESS","GRTR","L_SHIFT","R_SHIFT","PLUS","MINUS",
"STAR","DIV","MOD","CAST","UNARY","NOT","B_NOT","SIZEOF","INCR","DECR","HYPERUNARY",
"ARROW","DOT","LPAREN","LBRCKT","program","trans_unit","top_level_exit","top_level_decl",
"func_def","func_spec","cmpnd_stemnt","@1","opt_stemnt_list","stemnt_list","stemnt",
"cmpnd_stemnt_reentrance","opt_stemnt_list_reentrance","stemnt_list_reentrance",
"stemnt_reentrance","expr_stemnt","labeled_stemnt","cond_stemnt","iter_stemnt",
"switch_stemnt","break_stemnt","continue_stemnt","return_stemnt","goto_stemnt",
"null_stemnt","if_stemnt","if_else_stemnt","do_stemnt","while_stemnt","for_stemnt",
"label","named_label","case_label","deflt_label","cond_expr","assign_expr","opt_const_expr",
"const_expr","opt_expr","expr","log_or_expr","log_and_expr","log_neg_expr","bitwise_or_expr",
"bitwise_xor_expr","bitwise_and_expr","bitwise_neg_expr","cast_expr","equality_expr",
"relational_expr","shift_expr","additive_expr","mult_expr","unary_expr","sizeof_expr",
"unary_minus_expr","unary_plus_expr","addr_expr","indirection_expr","preinc_expr",
"predec_expr","comma_expr","prim_expr","paren_expr","postfix_expr","subscript_expr",
"comp_select_expr","postinc_expr","postdec_expr","field_ident","direct_comp_select",
"indirect_comp_select","func_call","opt_expr_list","expr_list","add_op","mult_op",
"equality_op","relation_op","shift_op","assign_op","constant","opt_KnR_declaration_list",
"@2","@3","@4","opt_declaration_list","@5","@6","@7","declaration_list","decl_stemnt",
"old_style_declaration","declaration","no_decl_specs","decl_specs","abs_decl",
"type_name","@8","type_name_bis","decl_specs_reentrance_bis","local_or_global_storage_class",
"local_storage_class","storage_class","type_spec","opt_decl_specs_reentrance",
"decl_specs_reentrance","@9","opt_comp_decl_specs","comp_decl_specs_reentrance",
"@10","comp_decl_specs","decl","@11","init_decl","opt_init_decl_list","init_decl_list",
"init_decl_list_reentrance","initializer","initializer_list","initializer_reentrance",
"opt_comma","type_qual","type_qual_token","type_qual_list","opt_type_qual_list",
"type_spec_reentrance","typedef_name","tag_ref","struct_tag_ref","union_tag_ref",
"enum_tag_ref","struct_tag_def","struct_type_define","union_tag_def","union_type_define",
"enum_tag_def","enum_type_define","struct_or_union_definition","enum_definition",
"opt_trailing_comma","enum_def_list","enum_def_list_reentrance","enum_const_def",
"enum_constant","field_list","@12","@13","field_list_reentrance","comp_decl",
"comp_decl_list","comp_decl_list_reentrance","@14","@15","comp_declarator","simple_comp",
"bit_field","@16","width","opt_declarator","declarator","func_declarator","declarator_reentrance_bis",
"direct_declarator_reentrance_bis","direct_declarator_reentrance","array_decl",
"pointer_start","pointer_reentrance","pointer","ident_list","@17","ident_list_reentrance",
"ident","typename_as_ident","any_ident","opt_param_type_list","@18","param_type_list",
"@19","param_type_list_bis","param_list","param_decl","@20","param_decl_bis",
"abs_decl_reentrance","direct_abs_decl_reentrance_bis","direct_abs_decl_reentrance",
"opt_gcc_attrib","gcc_attrib","gcc_inner", NULL
};
#endif

static const short yyr1[] = {     0,
   118,   118,   118,   119,   119,   120,   121,   121,   121,   121,
   121,   122,   123,   123,   125,   124,   124,   126,   126,   127,
   127,   127,   128,   129,   129,   130,   130,   131,   131,   131,
   132,   132,   132,   132,   132,   132,   132,   132,   132,   132,
   132,   132,   133,   134,   135,   135,   136,   136,   136,   137,
   138,   139,   140,   141,   142,   143,   144,   145,   146,   147,
   148,   148,   148,   149,   150,   150,   151,   152,   152,   153,
   153,   154,   154,   155,   156,   156,   157,   158,   158,   159,
   159,   160,   161,   161,   162,   162,   163,   163,   164,   165,
   165,   166,   166,   167,   167,   168,   168,   169,   169,   170,
   170,   171,   171,   171,   171,   171,   171,   171,   171,   171,
   171,   172,   172,   173,   174,   175,   176,   177,   178,   179,
   179,   180,   180,   180,   181,   181,   182,   182,   182,   182,
   182,   182,   183,   184,   184,   185,   186,   187,   188,   189,
   190,   191,   191,   192,   192,   193,   193,   194,   194,   194,
   195,   196,   197,   197,   198,   198,   199,   199,   199,   199,
   199,   199,   201,   200,   202,   203,   200,   205,   204,   206,
   207,   204,   208,   208,   209,   209,   210,   211,   212,   213,
   214,   216,   215,   217,   217,   218,   219,   219,   219,   220,
   220,   221,   221,   222,   223,   223,   224,   225,   224,   224,
   226,   226,   228,   227,   227,   229,   231,   230,   232,   232,
   233,   233,   234,   235,   235,   236,   237,   237,   238,   238,
   239,   239,   240,   241,   241,   242,   242,   243,   243,   244,
   244,   244,   244,   244,   244,   244,   244,   244,   244,   244,
   244,   244,   244,   244,   244,   244,   244,   244,   244,   244,
   245,   246,   247,   248,   249,   250,   251,   251,   252,   253,
   253,   254,   255,   255,   256,   256,   257,   257,   258,   258,
   259,   260,   260,   261,   261,   262,   264,   265,   263,   266,
   266,   266,   267,   267,   268,   270,   269,   271,   269,   272,
   272,   273,   275,   274,   276,   277,   277,   278,   279,   280,
   280,   281,   282,   282,   282,   282,   282,   282,   283,   284,
   285,   285,   286,   288,   287,   289,   289,   290,   291,   292,
   292,   293,   294,   293,   296,   295,   297,   297,   298,   298,
   300,   299,   301,   301,   301,   302,   302,   302,   303,   304,
   304,   304,   304,   304,   305,   305,   306,   307,   307,   307,
   307,   307,   307,   307,   307,   307
};

static const short yyr2[] = {     0,
     0,     1,     1,     2,     3,     0,     1,     1,     1,     2,
     3,     2,     3,     3,     0,     5,     2,     0,     1,     1,
     2,     2,     1,     4,     2,     0,     1,     1,     2,     2,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     2,     2,     3,     1,     1,     1,     1,     1,     5,
     2,     2,     3,     3,     1,     5,     7,     7,     5,     9,
     1,     1,     1,     1,     2,     4,     1,     1,     5,     1,
     3,     0,     1,     1,     0,     1,     1,     1,     3,     1,
     3,     2,     1,     3,     1,     3,     1,     3,     2,     1,
     4,     1,     3,     1,     3,     1,     3,     1,     3,     1,
     3,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     4,     2,     2,     2,     2,     2,     2,     2,     1,
     3,     1,     1,     1,     3,     3,     1,     1,     1,     1,
     1,     1,     4,     1,     1,     2,     2,     1,     3,     3,
     4,     0,     1,     1,     3,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     0,     1,     0,     0,     3,     0,     1,     0,
     0,     3,     2,     3,     2,     2,     2,     2,     0,     1,
     1,     0,     2,     1,     2,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     0,     1,     2,     0,     3,     2,
     0,     1,     0,     3,     2,     1,     0,     3,     1,     3,
     0,     1,     1,     1,     3,     1,     1,     3,     1,     4,
     0,     1,     1,     1,     1,     1,     2,     0,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     2,     2,     2,     2,     4,     4,     2,     4,
     4,     2,     4,     4,     0,     1,     0,     2,     0,     1,
     1,     1,     3,     1,     3,     1,     0,     0,     3,     2,
     2,     3,     2,     1,     1,     0,     3,     0,     5,     1,
     1,     1,     0,     4,     1,     0,     1,     1,     1,     2,
     1,     1,     1,     3,     1,     4,     4,     3,     4,     2,
     1,     2,     1,     0,     2,     1,     3,     1,     1,     1,
     1,     0,     0,     2,     0,     2,     1,     3,     1,     3,
     0,     2,     2,     2,     1,     1,     1,     2,     1,     3,
     3,     4,     3,     4,     0,     1,     6,     0,     1,     1,
     1,     1,     4,     4,     8,     1
};

static const short yydefact[] = {     0,
     3,   251,     9,   224,   225,   190,   187,   191,   188,   189,
   237,   238,   239,   240,   241,   242,   243,   244,   245,   246,
   247,   248,   249,   250,     0,     0,     0,     0,     6,     8,
     0,     7,     0,     0,   211,   211,   180,   192,   193,   195,
   198,   186,   195,   223,   194,   236,   234,   235,   233,     0,
   231,     0,   232,     0,   230,     6,    10,   252,   267,   255,
   277,   253,   277,   254,     0,     6,     4,     0,    15,    12,
   175,   176,   318,   228,     0,   209,   214,   177,   212,   213,
   165,   298,   301,   302,   305,   311,   313,     0,   303,   178,
   207,   165,   299,   197,   196,   195,   200,   277,   277,   267,
    11,   319,     0,   269,   271,   272,   274,   320,   321,   276,
     0,   266,   278,     0,     5,    17,   168,   226,   229,   310,
     0,     0,     0,    14,   164,   166,   345,   325,    72,   312,
   300,    13,   199,     0,     0,     0,   263,   270,   268,     0,
   257,     0,   260,     0,   169,   171,   227,   304,   161,   162,
   159,   160,   157,   158,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,    70,   219,    68,    78,   106,
    80,    83,    85,   107,   100,    87,    92,    94,    96,    98,
    90,   103,   104,   105,   108,   109,   110,   111,   127,   123,
   102,   128,   129,   131,   132,   134,   135,   130,   124,   210,
   216,   122,   215,     0,     0,   208,   346,   308,     0,     0,
     0,   331,   120,     0,    73,    74,    77,   258,   261,   264,
   273,   275,   206,   286,   201,   203,   279,     0,     0,     0,
     0,     0,    67,     0,     0,     0,     0,    75,     0,     0,
   168,    55,     0,     0,    20,    33,    23,    31,    32,    34,
    35,    36,    37,    38,    39,    40,    41,    45,    46,    47,
    48,    49,     0,    61,    62,    63,     0,   122,     0,   221,
   217,   116,    90,   115,   114,   117,    82,    89,     0,   113,
     0,   118,   119,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   151,     0,   152,     0,   153,   154,     0,
   146,   147,     0,   148,   149,   150,     0,   155,   156,     0,
   136,   137,     0,     0,   142,     0,   167,     0,   211,     0,
   307,   315,   316,   306,   326,   327,   329,     0,   309,     0,
   283,   285,   296,   205,   202,   201,   281,     0,   280,    25,
    42,    51,    65,    52,     0,     0,    75,     0,     0,    76,
     0,     0,     0,    16,    22,    21,     0,    43,   172,   222,
     0,     0,   126,   125,     0,   183,   184,     0,    79,    81,
    84,    86,    88,    93,    95,    97,    99,   101,    71,   140,
   138,   139,   144,     0,   143,     0,   173,   348,     0,   331,
   335,   332,   121,   288,   345,   290,   291,     0,   292,   204,
   282,     0,     0,     0,     0,    54,    53,     0,     0,     0,
     0,    28,    44,   218,   220,   112,    91,   323,    72,   185,
   336,   181,   337,   339,     0,   141,     0,   133,   174,   351,
     0,   349,   350,     0,     0,   352,   356,     0,   317,   328,
   330,   323,   333,   336,   334,   296,   287,   293,    66,     0,
     0,    75,     0,     0,    24,    30,    29,     0,   331,     0,
     0,   338,   323,    72,    69,   145,     0,     0,     0,     0,
   345,     0,     0,    56,     0,    50,    59,   343,   324,   340,
   341,     0,     0,     0,     0,     0,   347,   289,   295,   294,
     0,     0,    75,   344,   342,   353,   354,     0,    58,    57,
     0,     0,     0,     0,    60,     0,   355,     0,     0,     0
};

static const short yydefgoto[] = {   508,
    28,    67,    29,    30,    31,    70,   117,   243,   244,   245,
   246,   410,   411,   247,   248,   249,   250,   251,   252,   253,
   254,   255,   256,   257,   258,   259,   260,   261,   262,   263,
   264,   265,   266,   166,   213,   214,   215,   349,   267,   168,
   169,   170,   171,   172,   173,   174,   175,   176,   177,   178,
   179,   180,   181,   182,   183,   184,   185,   186,   187,   188,
   217,   189,   190,   191,   192,   193,   194,   195,   380,   196,
   197,   198,   384,   385,   303,   307,   295,   297,   300,   310,
   199,   124,   125,   126,   204,   144,   145,   146,   269,   317,
    32,    33,   318,    35,   319,   420,   286,   287,   366,    37,
    38,    39,    40,    41,    94,    42,    96,   334,   223,   336,
   224,    76,   127,    77,    90,    79,    80,   200,   270,   201,
   361,    43,    44,   119,   120,    45,    46,    60,    47,    48,
    49,    50,    51,    52,    53,    54,    55,   111,   103,   139,
   104,   105,   106,   107,   112,   113,   142,   227,   228,   331,
   332,   333,   446,   395,   396,   397,   472,   490,   398,    91,
    92,    82,    83,    84,    85,    86,    87,    88,   209,   210,
   322,   202,   109,   110,   458,   459,   211,   212,   325,   326,
   327,   328,   392,   460,   423,   424,   206,   207,   438
};

static const short yypact[] = {   362,
    18,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,    32,    40,    47,   466,-32768,-32768,
    33,-32768,   -14,    -6,    53,    53,-32768,-32768,-32768,  1041,
-32768,-32768,  1041,-32768,-32768,-32768,-32768,-32768,-32768,     4,
-32768,    29,-32768,    31,-32768,-32768,-32768,-32768,    61,    55,
     9,    68,     9,    94,    18,-32768,-32768,    95,-32768,-32768,
-32768,-32768,-32768,    75,    53,    82,-32768,-32768,-32768,   112,
    41,-32768,-32768,    12,-32768,-32768,    81,    35,-32768,-32768,
-32768,    34,    96,-32768,-32768,  1041,-32768,     9,     9,    61,
-32768,-32768,   121,   123,-32768,-32768,   109,-32768,-32768,-32768,
   127,-32768,-32768,   129,-32768,-32768,  1074,-32768,    75,-32768,
   133,   569,    53,-32768,-32768,-32768,   124,    51,   903,-32768,
-32768,-32768,-32768,   134,   137,   138,-32768,    61,-32768,   903,
-32768,   414,-32768,   727,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,   569,   903,   903,   903,   903,   903,
   903,   922,   934,   934,   521,-32768,-32768,   -18,   116,-32768,
   118,   115,   119,-32768,-32768,   117,   122,    43,    39,    28,
    85,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
   143,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,  1041,    98,-32768,-32768,-32768,   150,   214,
   154,-32768,-32768,   157,-32768,-32768,   159,-32768,-32768,-32768,
-32768,-32768,-32768,   155,   414,-32768,   953,   158,   105,   164,
   903,   166,-32768,   855,   128,   140,   232,   903,   145,   146,
  1074,-32768,   177,   599,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,   175,-32768,-32768,-32768,   195,   178,  1041,   197,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   521,-32768,
   231,-32768,-32768,   200,   203,   205,  1041,   903,   903,   903,
   903,   903,   903,-32768,   903,-32768,   903,-32768,-32768,   903,
-32768,-32768,   903,-32768,-32768,-32768,   903,-32768,-32768,   903,
-32768,-32768,    61,    61,   903,   903,-32768,   202,    53,   156,
-32768,   204,-32768,-32768,-32768,   207,-32768,  1041,-32768,   903,
-32768,   211,    53,-32768,-32768,   414,-32768,   206,-32768,-32768,
-32768,-32768,   212,-32768,   223,   903,   903,   216,   217,-32768,
   903,   903,   777,-32768,-32768,-32768,   855,-32768,-32768,   569,
   219,   224,-32768,-32768,   903,-32768,   -42,   208,   116,   118,
   115,   119,   117,   122,    43,    39,    28,-32768,-32768,-32768,
-32768,-32768,-32768,   225,   218,   226,  1041,   170,   214,   220,
    42,-32768,-32768,-32768,   124,-32768,-32768,   209,   213,-32768,
-32768,   903,   179,   229,   230,-32768,-32768,   237,   238,   236,
   649,-32768,-32768,-32768,-32768,-32768,-32768,     3,   903,-32768,
    60,-32768,-32768,    63,   903,-32768,   903,-32768,-32768,-32768,
   189,-32768,-32768,   190,   191,-32768,-32768,   243,-32768,-32768,
-32768,    20,-32768,    22,-32768,    53,-32768,-32768,-32768,   903,
   855,   903,   855,   855,-32768,-32768,-32768,   244,-32768,   245,
   246,-32768,   249,   903,-32768,-32768,   300,   214,   214,   250,
   124,   903,   251,   273,   252,-32768,-32768,-32768,-32768,-32768,
-32768,   254,   257,   255,   262,   258,-32768,-32768,-32768,-32768,
   261,   855,   903,-32768,-32768,-32768,-32768,   320,-32768,-32768,
   270,   266,   855,   326,-32768,   279,-32768,   345,   346,-32768
};

static const short yypgoto[] = {-32768,
-32768,    10,   321,-32768,-32768,-32768,-32768,-32768,-32768,   104,
-32768,-32768,-32768,  -223,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,  -368,  -114,  -346,  -219,  -325,  -126,-32768,
    62,-32768,    65,    59,    67,-32768,  -129,    64,    57,    56,
    66,    69,  -143,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    46,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,   272,-32768,-32768,-32768,   130,-32768,-32768,-32768,  -262,
-32768,-32768,    50,-32768,    52,-32768,    90,-32768,-32768,  -239,
-32768,-32768,-32768,-32768,     6,    19,-32768,    37,  -192,-32768,
-32768,-32768,-32768,   247,   339,-32768,-32768,-32768,-32768,  -149,
-32768,  -133,     5,-32768,-32768,  -132,-32768,   160,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,   -16,   301,-32768,
-32768,-32768,   264,-32768,-32768,-32768,-32768,-32768,   176,-32768,
-32768,-32768,-32768,   -41,-32768,-32768,-32768,-32768,-32768,   -33,
-32768,   -32,   -83,-32768,-32768,   317,-32768,  -321,-32768,-32768,
-32768,   -35,-32768,  -122,   -57,-32768,-32768,-32768,   -51,-32768,
    24,-32768,-32768,  -307,  -363,-32768,  -358,-32768,-32768
};


#define	YYLAST		1112


static const short yytable[] = {    89,
    89,    81,   216,    93,   131,   271,   359,   167,   225,   226,
   345,   343,   273,   273,   273,   273,   273,   273,   280,   282,
   283,   405,    73,   108,    73,   222,   272,   274,   275,   276,
   277,   278,   335,    68,  -163,    58,   447,    73,   285,    89,
   167,  -163,   121,    58,    73,   421,   114,   367,    97,    34,
    58,    36,    89,  -314,    71,    73,   465,   462,    95,   422,
    74,    95,    72,    73,   108,   101,   102,  -322,   288,   444,
    98,   289,   461,   418,   419,   115,  -265,    34,   118,    36,
   462,   134,   135,   445,  -322,    56,    57,    89,   391,     4,
     5,   225,   226,   225,   226,    99,   421,   100,    59,    69,
  -163,   133,   108,   489,   216,    74,    61,  -163,   268,  -207,
  -207,   350,   488,    63,    95,   208,  -207,   483,   418,   419,
   444,  -262,    74,   147,   429,  -207,   475,   128,   129,   412,
   304,   305,   306,   413,  -256,   442,   419,   442,   419,   301,
   302,   298,   299,   335,    74,   273,   273,   273,   273,   273,
    75,   273,   285,   273,   285,    74,   273,   442,   419,   273,
  -259,   368,   116,   273,  -298,  -298,   122,   501,    75,   308,
   309,  -298,   340,   341,   323,   418,   419,   378,   463,   464,
  -298,   123,   449,    74,   430,    62,    64,   457,   137,   386,
   381,   381,   138,   140,   141,   379,   143,   148,   268,   205,
   383,   218,   225,   226,   219,   220,   290,   292,   268,   291,
   414,   294,   293,   320,   321,   393,    73,   296,   324,   404,
   350,   273,   329,  -284,   408,   409,   339,   474,   330,   476,
   477,   284,   342,    73,   344,   417,   348,   149,   150,   151,
   152,   153,   154,   346,   354,   167,   431,   432,   433,   434,
   435,   436,   437,   311,   312,   347,   313,   314,   315,   316,
   351,   352,   357,   358,   363,   -64,   360,   364,   500,   365,
   387,   388,   403,   389,   401,   216,   390,   108,   108,   505,
   394,   273,   402,    89,   406,   407,   415,   427,   416,   426,
   440,   428,   216,   451,   450,   425,   448,    89,   452,   399,
  -297,   453,   454,   455,   467,   468,   469,   470,   478,   480,
   484,   481,   466,  -322,   487,   491,   492,   268,   494,   496,
   493,   268,   495,   473,   156,   350,   497,   498,   273,   499,
   502,   157,   158,   159,   503,   504,   506,   216,   160,   161,
   162,   163,   164,   507,   509,   510,   165,   356,    66,   371,
   369,   374,   375,   439,   370,    89,   373,   443,   372,   382,
   131,    -1,     1,   132,  -179,   376,   350,     2,   362,   203,
   353,   377,   400,    78,     3,   268,     4,     5,     6,     7,
     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,
    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
   136,   221,   338,   130,   471,   482,    89,   479,    89,   121,
    89,     0,   399,   441,     0,   268,     0,   268,   268,     2,
     0,     0,     0,     0,     0,     0,     0,     0,     4,     5,
  -179,     0,   485,   486,     0,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
    26,    27,     0,     0,     0,     0,   268,     0,     0,     0,
     0,     0,     0,     0,  -179,    -2,    65,   268,  -179,     0,
     0,     2,     0,     0,     0,     0,     0,  -179,     3,     0,
     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,
    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,
    24,    25,    26,    27,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   284,     0,    73,     0,     0,  -182,   149,   150,   151,
   152,   153,   154,     0,  -179,  -182,  -182,  -182,  -182,  -182,
  -182,  -182,  -182,  -182,  -182,  -182,  -182,  -182,  -182,  -182,
  -182,  -182,  -182,  -182,  -182,  -182,  -182,  -182,  -182,     0,
     0,     0,     0,     0,     0,     0,     0,     0,  -179,     0,
     0,    73,     0,     0,     0,   149,   150,   151,   152,   153,
   154,  -179,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   229,
     0,    73,     0,     0,     0,   149,   150,   151,   152,   153,
   154,   355,     0,     0,   156,     0,     0,     0,     0,     0,
     0,   157,   158,   159,     0,     0,     0,     0,   160,   161,
   162,   163,   164,     0,     0,   155,   165,   230,   231,   232,
   233,   234,     0,   235,   236,   237,   238,   239,   240,   229,
     0,    73,     0,     0,     0,   149,   150,   151,   152,   153,
   154,   456,   156,     0,     0,   241,   -19,   242,     0,   157,
   158,   159,     0,     0,     0,     0,   160,   161,   162,   163,
   164,     0,     0,     0,   165,     0,     0,   230,   231,   232,
   233,   234,   156,   235,   236,   237,   238,   239,   240,   157,
   158,   159,     0,     0,     0,     0,   160,   161,   162,   163,
   164,     0,     0,     0,   165,   241,   -27,   242,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   229,     0,    73,
     0,     0,     0,   149,   150,   151,   152,   153,   154,     0,
     0,     0,   156,     0,     0,     0,     0,     0,     0,   157,
   158,   159,     0,     0,     0,     0,   160,   161,   162,   163,
   164,     0,     0,     0,   165,   230,   231,   232,   233,   234,
     0,   235,   236,   237,   238,   239,   240,   229,     0,    73,
     0,     0,     0,   149,   150,   151,   152,   153,   154,     0,
     0,     0,     0,   241,   -18,   242,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   230,   231,   232,   233,   234,
   156,   235,   236,   237,   238,   239,   240,   157,   158,   159,
     0,     0,     0,     0,   160,   161,   162,   163,   164,     0,
     0,     0,   165,   241,   -26,   242,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   229,     0,    73,     0,     0,
     0,   149,   150,   151,   152,   153,   154,     0,     0,     0,
   156,     0,     0,     0,     0,     0,     0,   157,   158,   159,
     0,     0,     0,     0,   160,   161,   162,   163,   164,     0,
     0,     0,   165,   230,   231,   232,   233,   234,     0,   235,
   236,   237,   238,   239,   240,    73,     0,     0,     0,   149,
   150,   151,   152,   153,   154,     0,     0,     0,     0,     0,
     0,   241,     0,   242,    73,     0,     0,     0,   149,   150,
   151,   152,   153,   154,     0,     0,    73,     0,     0,     0,
   149,   150,   151,   152,   153,   154,     0,     0,   156,     0,
     0,     0,     0,     0,     0,   157,   158,   159,     2,     0,
     0,     0,   160,   161,   162,   163,   164,     4,     5,     0,
   165,     0,     0,     0,    11,    12,    13,    14,    15,    16,
    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
    27,     0,     0,     0,     0,     0,   156,     0,     0,     0,
     0,     0,     0,   157,   158,   159,     0,     0,     0,     0,
   160,   161,   162,   163,   164,   156,     0,     0,   165,     0,
     0,   337,   157,   158,   159,     0,     0,   156,     0,   160,
   161,   162,   163,   164,   157,   158,   159,   279,     0,     0,
     0,   160,   161,   162,   163,   164,     2,     0,     0,   281,
     0,     0,     0,     0,     0,     4,     5,     6,     7,     8,
     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
    19,    20,    21,    22,    23,    24,    25,    26,    27,  -170,
     0,     0,     0,     0,     0,     0,     0,     0,  -170,  -170,
  -170,  -170,  -170,  -170,  -170,  -170,  -170,  -170,  -170,  -170,
  -170,  -170,  -170,  -170,  -170,  -170,  -170,  -170,  -170,  -170,
  -170,  -170
};

static const short yycheck[] = {    35,
    36,    35,   129,    36,    88,   155,   269,   122,   142,   142,
   234,   231,   156,   157,   158,   159,   160,   161,   162,   163,
   164,   347,     3,    59,     3,   140,   156,   157,   158,   159,
   160,   161,   225,     1,     1,     4,   395,     3,   165,    75,
   155,     1,    75,     4,     3,   367,    63,   287,    43,     0,
     4,     0,    88,     3,    69,     3,   425,   421,    40,   367,
   103,    43,    69,     3,   100,    56,     6,    65,    87,   391,
    67,    90,   419,   116,   117,    66,    68,    28,    74,    28,
   444,    98,    99,   391,    65,    68,    69,   123,   328,    15,
    16,   225,   225,   227,   227,    67,   418,    67,    67,    67,
    67,    96,   138,   472,   231,   103,    67,    67,   144,    69,
    70,   238,   471,    67,    96,    65,    76,   464,   116,   117,
   442,    67,   103,   119,   387,    85,   452,   116,   117,   353,
   103,   104,   105,   357,    67,   116,   117,   116,   117,   101,
   102,    99,   100,   336,   103,   289,   290,   291,   292,   293,
   116,   295,   279,   297,   281,   103,   300,   116,   117,   303,
    67,   288,    68,   307,    69,    70,    85,   493,   116,    85,
    86,    76,    68,    69,   210,   116,   117,   307,   116,   117,
    85,    70,   402,   103,    15,    26,    27,   411,    68,   316,
   313,   314,    70,    85,    68,   310,    68,    65,   234,    76,
   315,    68,   336,   336,    68,    68,    91,    93,   244,    92,
   360,    95,    94,   116,    65,   330,     3,    96,    65,   346,
   347,   365,    66,    69,   351,   352,    69,   451,    70,   453,
   454,     1,    69,     3,    69,   365,     5,     7,     8,     9,
    10,    11,    12,   116,    68,   360,    77,    78,    79,    80,
    81,    82,    83,   111,   112,   116,   114,   115,   116,   117,
   116,   116,    88,    69,    65,    88,    70,    65,   492,    65,
    69,   116,    50,    70,    69,   402,    70,   313,   314,   503,
    70,   425,    71,   319,    69,    69,    68,    70,    65,    65,
    71,    66,   419,    65,   116,    88,    88,   333,    69,   333,
    88,    65,    65,    68,   116,   116,   116,    65,    65,    65,
    11,    66,   427,    65,    65,    65,    44,   353,    65,    65,
    69,   357,    66,   450,    94,   452,    65,    70,   472,    69,
    11,   101,   102,   103,    65,    70,    11,   464,   108,   109,
   110,   111,   112,    65,     0,     0,   116,   244,    28,   291,
   289,   295,   297,   389,   290,   391,   293,   391,   292,   314,
   444,     0,     1,    92,     3,   300,   493,     6,   279,   123,
   241,   303,   336,    35,    13,   411,    15,    16,    17,    18,
    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,
   100,   138,   227,    87,   446,   463,   442,   459,   444,   442,
   446,    -1,   446,   390,    -1,   451,    -1,   453,   454,     6,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    15,    16,
    69,    -1,   468,   469,    -1,    22,    23,    24,    25,    26,
    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,
    37,    38,    -1,    -1,    -1,    -1,   492,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,   103,     0,     1,   503,     3,    -1,
    -1,     6,    -1,    -1,    -1,    -1,    -1,   116,    13,    -1,
    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
    35,    36,    37,    38,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,     1,    -1,     3,    -1,    -1,     6,     7,     8,     9,
    10,    11,    12,    -1,    69,    15,    16,    17,    18,    19,
    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,
    30,    31,    32,    33,    34,    35,    36,    37,    38,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   103,    -1,
    -1,     3,    -1,    -1,    -1,     7,     8,     9,    10,    11,
    12,   116,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     1,
    -1,     3,    -1,    -1,    -1,     7,     8,     9,    10,    11,
    12,    13,    -1,    -1,    94,    -1,    -1,    -1,    -1,    -1,
    -1,   101,   102,   103,    -1,    -1,    -1,    -1,   108,   109,
   110,   111,   112,    -1,    -1,    67,   116,    39,    40,    41,
    42,    43,    -1,    45,    46,    47,    48,    49,    50,     1,
    -1,     3,    -1,    -1,    -1,     7,     8,     9,    10,    11,
    12,    13,    94,    -1,    -1,    67,    68,    69,    -1,   101,
   102,   103,    -1,    -1,    -1,    -1,   108,   109,   110,   111,
   112,    -1,    -1,    -1,   116,    -1,    -1,    39,    40,    41,
    42,    43,    94,    45,    46,    47,    48,    49,    50,   101,
   102,   103,    -1,    -1,    -1,    -1,   108,   109,   110,   111,
   112,    -1,    -1,    -1,   116,    67,    68,    69,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,     1,    -1,     3,
    -1,    -1,    -1,     7,     8,     9,    10,    11,    12,    -1,
    -1,    -1,    94,    -1,    -1,    -1,    -1,    -1,    -1,   101,
   102,   103,    -1,    -1,    -1,    -1,   108,   109,   110,   111,
   112,    -1,    -1,    -1,   116,    39,    40,    41,    42,    43,
    -1,    45,    46,    47,    48,    49,    50,     1,    -1,     3,
    -1,    -1,    -1,     7,     8,     9,    10,    11,    12,    -1,
    -1,    -1,    -1,    67,    68,    69,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    39,    40,    41,    42,    43,
    94,    45,    46,    47,    48,    49,    50,   101,   102,   103,
    -1,    -1,    -1,    -1,   108,   109,   110,   111,   112,    -1,
    -1,    -1,   116,    67,    68,    69,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,     1,    -1,     3,    -1,    -1,
    -1,     7,     8,     9,    10,    11,    12,    -1,    -1,    -1,
    94,    -1,    -1,    -1,    -1,    -1,    -1,   101,   102,   103,
    -1,    -1,    -1,    -1,   108,   109,   110,   111,   112,    -1,
    -1,    -1,   116,    39,    40,    41,    42,    43,    -1,    45,
    46,    47,    48,    49,    50,     3,    -1,    -1,    -1,     7,
     8,     9,    10,    11,    12,    -1,    -1,    -1,    -1,    -1,
    -1,    67,    -1,    69,     3,    -1,    -1,    -1,     7,     8,
     9,    10,    11,    12,    -1,    -1,     3,    -1,    -1,    -1,
     7,     8,     9,    10,    11,    12,    -1,    -1,    94,    -1,
    -1,    -1,    -1,    -1,    -1,   101,   102,   103,     6,    -1,
    -1,    -1,   108,   109,   110,   111,   112,    15,    16,    -1,
   116,    -1,    -1,    -1,    22,    23,    24,    25,    26,    27,
    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,
    38,    -1,    -1,    -1,    -1,    -1,    94,    -1,    -1,    -1,
    -1,    -1,    -1,   101,   102,   103,    -1,    -1,    -1,    -1,
   108,   109,   110,   111,   112,    94,    -1,    -1,   116,    -1,
    -1,    69,   101,   102,   103,    -1,    -1,    94,    -1,   108,
   109,   110,   111,   112,   101,   102,   103,   116,    -1,    -1,
    -1,   108,   109,   110,   111,   112,     6,    -1,    -1,   116,
    -1,    -1,    -1,    -1,    -1,    15,    16,    17,    18,    19,
    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,
    30,    31,    32,    33,    34,    35,    36,    37,    38,     6,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    15,    16,
    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,
    37,    38
};
#define YYPURE 1

/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
#line 3 "/usr/lib/bison.simple"

/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

#ifndef alloca
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
#include <alloca.h>
#else /* not sparc */
#if defined (MSDOS) && !defined (__TURBOC__)
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
#include <malloc.h>
 #pragma alloca
#else /* not MSDOS, __TURBOC__, or _AIX */
#ifdef __hpux
#ifdef __cplusplus
extern "C" {
void *alloca (unsigned int);
};
#else /* not __cplusplus */
void *alloca ();
#endif /* not __cplusplus */
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc.  */
#endif /* not GNU C.  */
#endif /* alloca not defined.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYACCEPT	return(0)
#define YYABORT 	return(1)
#define YYERROR		goto yyerrlab1
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL		goto yyerrlab
#define YYRECOVERING()  (!!yyerrstatus)
#define YYBACKUP(token, value) \
do								\
  if (yychar == YYEMPTY && yylen == 1)				\
    { yychar = (token), yylval = (value);			\
      yychar1 = YYTRANSLATE (yychar);				\
      YYPOPSTACK;						\
      goto yybackup;						\
    }								\
  else								\
    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
while (0)

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYPURE
#define YYLEX		yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#ifdef YYLEX_PARAM
#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
#else
#define YYLEX		yylex(&yylval, &yylloc)
#endif
#else /* not YYLSP_NEEDED */
#ifdef YYLEX_PARAM
#define YYLEX		yylex(&yylval, YYLEX_PARAM)
#else
#define YYLEX		yylex(&yylval)
#endif
#endif /* not YYLSP_NEEDED */
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int	yychar;			/*  the lookahead symbol		*/
YYSTYPE	yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef YYLSP_NEEDED
YYLTYPE yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int yynerrs;			/*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int yydebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
int yyparse (void);
#endif

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (to, from, count)
     char *to;
     char *from;
     int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (char *to, char *from, int count)
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#endif
#endif

#line 196 "/usr/lib/bison.simple"

/* The user can define YYPARSE_PARAM as the name of an argument to be passed
   into yyparse.  The argument should have type void *.
   It should actually point to an object.
   Grammar actions can access the variable by casting it
   to the proper pointer type.  */

#ifdef YYPARSE_PARAM
#ifdef __cplusplus
#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#else /* not __cplusplus */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
#endif /* not __cplusplus */
#else /* not YYPARSE_PARAM */
#define YYPARSE_PARAM_ARG
#define YYPARSE_PARAM_DECL
#endif /* not YYPARSE_PARAM */

int
yyparse(YYPARSE_PARAM_ARG)
     YYPARSE_PARAM_DECL
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YYSTYPE *yyvsp;
  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/

  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
  YYLTYPE *yyls = yylsa;
  YYLTYPE *yylsp;

#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK   (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YYPURE
  int yychar;
  YYSTYPE yylval;
  int yynerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE yylloc;
#endif
#endif

  YYSTYPE yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int yylen;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YYLSP_NEEDED
  yylsp = yyls;
#endif

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *yyvs1 = yyvs;
      short *yyss1 = yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *yyls1 = yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if yyoverflow is a macro.  */
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yyls1, size * sizeof (*yylsp),
		 &yystacksize);
#else
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yystacksize);
#endif

      yyss = yyss1; yyvs = yyvs1;
#ifdef YYLSP_NEEDED
      yyls = yyls1;
#endif
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yystacksize >= YYMAXDEPTH)
	{
	  yyerror("parser stack overflow");
	  return 2;
	}
      yystacksize *= 2;
      if (yystacksize > YYMAXDEPTH)
	yystacksize = YYMAXDEPTH;
      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
      __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));
      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
      __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));
#ifdef YYLSP_NEEDED
      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
      __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));
#endif
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
#ifdef YYLSP_NEEDED
      yylsp = yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

      if (yyssp >= yyss + yystacksize - 1)
	YYABORT;
    }

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Entering state %d\n", yystate);
#endif

  goto yybackup;
 yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (yychar == YYEMPTY)
    {
#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Reading a token: ");
#endif
      yychar = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)		/* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

#if YYDEBUG != 0
      if (yydebug)
	{
	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, yychar, yylval);
#endif
	  fprintf (stderr, ")\n");
	}
#endif
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;

/* Do the default action for the current state.  */
yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (yydebug)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       yyn, yyrline[yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
#endif


  switch (yyn) {

case 1:
#line 228 "gram.y"
{
            if (gProject->Parse_TOS->err_cnt == 0)
              *gProject->Parse_TOS->yyerrstream
              << "Warning: ANSI/ISO C forbids an empty source file.\n";
            gProject->Parse_TOS->transUnit = (TransUnit*) NULL;
            yyval.transunit = (TransUnit*) NULL;
        ;
    break;}
case 2:
#line 236 "gram.y"
{
            if (gProject->Parse_TOS->err_cnt)
            {
                *gProject->Parse_TOS->yyerrstream
                << gProject->Parse_TOS->err_cnt << " errors found.\n";
                gProject->Parse_TOS->transUnit = (TransUnit*) NULL;
            } else {
                gProject->Parse_TOS->transUnit = yyval.transunit;
            }
        ;
    break;}
case 3:
#line 247 "gram.y"
{
            *gProject->Parse_TOS->yyerrstream << "Errors - Aborting parse.\n";
            gProject->Parse_TOS->transUnit = (TransUnit*) NULL;
            YYACCEPT;
        ;
    break;}
case 4:
#line 255 "gram.y"
{
            yyval.transunit = gProject->Parse_TOS->transUnit;
            yyval.transunit->add(yyvsp[-1].stemnt);
        ;
    break;}
case 5:
#line 260 "gram.y"
{
            yyval.transunit->add(yyvsp[-1].stemnt);
        ;
    break;}
case 6:
#line 266 "gram.y"
{
            gProject->Parse_TOS->parseCtxt->ReinitializeCtxt();
            if (gProject->Parse_TOS->transUnit)
                gProject->Parse_TOS->transUnit->contxt.ExitScopes(FILE_SCOPE);
            gProject->Parse_TOS->err_top_level = 0;            
        ;
    break;}
case 7:
#line 275 "gram.y"
{
            yyval.stemnt = yyvsp[0].declStemnt;
        ;
    break;}
case 8:
#line 279 "gram.y"
{
            yyval.stemnt = yyvsp[0].functionDef;
        ;
    break;}
case 9:
#line 283 "gram.y"
{
            yyval.stemnt = yyvsp[0].stemnt;
		;
    break;}
case 10:
#line 287 "gram.y"
{
            yyval.stemnt = (Statement*) NULL;
        ;
    break;}
case 11:
#line 291 "gram.y"
{
            yyval.stemnt = (Statement*) NULL;
        ;
    break;}
case 12:
#line 297 "gram.y"
{
            if (yyvsp[0].stemnt != NULL)
            {
                yyval.functionDef = new FunctionDef(yyvsp[0].stemnt->location);
                Block *blk = (Block*) yyvsp[0].stemnt;
    
                yyval.functionDef->decl = yyvsp[-1].decl;
                
                if (yyvsp[-1].decl->name &&
                    yyvsp[-1].decl->name->entry)
                    yyvsp[-1].decl->name->entry->u2FunctionDef = yyval.functionDef;
                
                // Steal internals of the compound statement
                yyval.functionDef->head = blk->head;
                yyval.functionDef->tail = blk->tail;
    
                blk->head = blk->tail = (Statement*) NULL;
                delete yyvsp[0].stemnt;    
            }
			else
			{
				delete yyvsp[-1].decl;
				yyval.functionDef = (FunctionDef*) NULL;
			}
        ;
    break;}
case 13:
#line 325 "gram.y"
{
            gProject->Parse_TOS->parseCtxt->ResetDeclCtxt();
            
            gProject->Parse_TOS->possibleType = true;
            yyval.decl = yyvsp[-1].decl;

            if (yyval.decl->form != NULL)
            {
                assert(gProject->Parse_TOS->err_top_level ||
                       yyval.decl->form->type == TT_Function );
    
                yyval.decl->extend(yyvsp[-2].base);
    
                /* This is adding K&R-style declarations if $3 exists */
                if (yyvsp[0].decl != NULL)
                {
                    FunctionType *fnc = (FunctionType*) (yyval.decl->form);
                    fnc->KnR_decl = true;
                    Decl *param = yyvsp[0].decl;
                    while (param != NULL)
                    {
                        Decl *next= param->next;
                            delete param ;
                        param = next;
                    }
                }
            }
        ;
    break;}
case 14:
#line 354 "gram.y"
{

            gProject->Parse_TOS->parseCtxt->ResetDeclCtxt();
            
            yyval.decl = yyvsp[-1].decl;

            if (yyval.decl->form != NULL)
            {
                assert(gProject->Parse_TOS->err_top_level ||
                       yyval.decl->form->type == TT_Function );
                yyval.decl->extend(yyvsp[-2].base);
    
                /* This is adding K&R-style declarations if $3 exists */
                if (yyvsp[0].decl != NULL)
                {
                    FunctionType *fnc = (FunctionType*) (yyval.decl->form);
                    fnc->KnR_decl = true;
                    Decl *param = yyvsp[0].decl;
                    while (param != NULL)
                    {
                        Decl *next= param->next;
                            delete param ;
                        param = next;
                    }
                }
            }
        ;
    break;}
case 15:
#line 387 "gram.y"
{  
            if (gProject->Parse_TOS->transUnit)
                gProject->Parse_TOS->transUnit->contxt.ReEnterScope();
        ;
    break;}
case 16:
#line 392 "gram.y"
{
            Block*    block = new Block(*yyvsp[-4].loc);
            yyval.stemnt = block;
            block->addDecls(yyvsp[-2].decl);
            block->addStatements(ReverseList(yyvsp[-1].stemnt));
            if (gProject->Parse_TOS->transUnit)
            {
                yyCheckLabelsDefinition(gProject->Parse_TOS->transUnit->contxt.labels);
                gProject->Parse_TOS->transUnit->contxt.ExitScope();
                gProject->Parse_TOS->transUnit->contxt.ExitScope();
            }
        ;
    break;}
case 17:
#line 405 "gram.y"
{
            yyval.stemnt = (Statement*) NULL;
        ;
    break;}
case 18:
#line 411 "gram.y"
{
            yyval.stemnt = (Statement*) NULL;
        ;
    break;}
case 21:
#line 419 "gram.y"
{
            /* Hook them up backwards, we'll reverse them later. */
            if (yyvsp[0].stemnt)
            {
                yyvsp[0].stemnt->next = yyvsp[-1].stemnt;
                yyval.stemnt = yyvsp[0].stemnt;
            }
        ;
    break;}
case 22:
#line 428 "gram.y"
{    /* preprocessor #line directive */
            /* Hook them up backwards, we'll reverse them later. */
            if (yyvsp[0].stemnt)
            {
                yyvsp[0].stemnt->next = yyvsp[-1].stemnt;
                yyval.stemnt = yyvsp[0].stemnt;
            }
        ;
    break;}
case 24:
#line 446 "gram.y"
{
            Block*    block = new Block(*yyvsp[-3].loc);
            yyval.stemnt = block;
            block->addDecls(yyvsp[-2].decl);
            block->addStatements(ReverseList(yyvsp[-1].stemnt));
            
            if (gProject->Parse_TOS->transUnit)
                gProject->Parse_TOS->transUnit->contxt.ExitScope();
        ;
    break;}
case 25:
#line 456 "gram.y"
{
            yyval.stemnt = (Statement*) NULL;
        ;
    break;}
case 26:
#line 462 "gram.y"
{
            yyval.stemnt = (Statement*) NULL;
        ;
    break;}
case 29:
#line 470 "gram.y"
{
            /* Hook them up backwards, we'll reverse them later. */
            if (yyvsp[0].stemnt)
            {
                yyvsp[0].stemnt->next = yyvsp[-1].stemnt;
                yyval.stemnt = yyvsp[0].stemnt;
            }
        ;
    break;}
case 30:
#line 479 "gram.y"
{    /* preprocessor #line directive */
            /* Hook them up backwards, we'll reverse them later. */
            if (yyvsp[0].stemnt)
            {
                yyvsp[0].stemnt->next = yyvsp[-1].stemnt;
                yyval.stemnt = yyvsp[0].stemnt;
            }
        ;
    break;}
case 42:
#line 501 "gram.y"
{
            delete yyvsp[0].loc;
            yyval.stemnt = (Statement*) NULL;
        ;
    break;}
case 43:
#line 508 "gram.y"
{
            yyval.stemnt = new ExpressionStemnt(yyvsp[-1].value,*yyvsp[0].loc);
            delete yyvsp[0].loc;
        ;
    break;}
case 44:
#line 515 "gram.y"
{
            yyval.stemnt = yyvsp[0].stemnt;
            if (yyval.stemnt == NULL)
            {
              /* Sorry, we must have a statement here. */
              if(yyerr("Can't have a label at the end of a block! "))
                YYERROR;
                
              yyval.stemnt = new Statement(ST_NullStemnt,*yyvsp[-1].loc);
            }
            yyval.stemnt->addHeadLabel(yyvsp[-2].label);
            delete yyvsp[-1].loc;
        ;
    break;}
case 50:
#line 540 "gram.y"
{
            yyval.stemnt = new SwitchStemnt(yyvsp[-2].value,yyvsp[0].stemnt,*yyvsp[-4].loc);
            delete yyvsp[-4].loc;
            delete yyvsp[-3].loc;
            delete yyvsp[-1].loc;
        ;
    break;}
case 51:
#line 549 "gram.y"
{
            yyval.stemnt = new Statement(ST_BreakStemnt,*yyvsp[-1].loc);
            delete yyvsp[-1].loc;
            delete yyvsp[0].loc;
        ;
    break;}
case 52:
#line 557 "gram.y"
{
            yyval.stemnt = new Statement(ST_ContinueStemnt,*yyvsp[-1].loc);
            delete yyvsp[-1].loc;
            delete yyvsp[0].loc;
        ;
    break;}
case 53:
#line 565 "gram.y"
{
            yyval.stemnt = new ReturnStemnt(yyvsp[-1].value,*yyvsp[-2].loc);
            delete yyvsp[-2].loc;
            delete yyvsp[0].loc;
        ;
    break;}
case 54:
#line 573 "gram.y"
{
            yyval.stemnt = new GotoStemnt(yyvsp[-1].symbol,*yyvsp[-2].loc);
            delete yyvsp[-2].loc;
            delete yyvsp[0].loc;
        ;
    break;}
case 55:
#line 581 "gram.y"
{
            yyval.stemnt = new Statement(ST_NullStemnt,*yyvsp[0].loc);
            delete yyvsp[0].loc;
        ;
    break;}
case 56:
#line 588 "gram.y"
{
            yyval.stemnt = new IfStemnt(yyvsp[-2].value,yyvsp[0].stemnt,*yyvsp[-4].loc);
            delete yyvsp[-4].loc;
            delete yyvsp[-3].loc;
            delete yyvsp[-1].loc;
        ;
    break;}
case 57:
#line 597 "gram.y"
{
            yyval.stemnt = new IfStemnt(yyvsp[-4].value,yyvsp[-2].stemnt,*yyvsp[-6].loc,yyvsp[0].stemnt);
            delete yyvsp[-6].loc;
            delete yyvsp[-5].loc;
            delete yyvsp[-3].loc;
            delete yyvsp[-1].loc;
        ;
    break;}
case 58:
#line 607 "gram.y"
{
            yyval.stemnt = new DoWhileStemnt(yyvsp[-2].value,yyvsp[-5].stemnt,*yyvsp[-6].loc);
            delete yyvsp[-6].loc;
            delete yyvsp[-4].loc;
            delete yyvsp[-3].loc;
            delete yyvsp[-1].loc;
            delete yyvsp[0].loc;
        ;
    break;}
case 59:
#line 618 "gram.y"
{
            yyval.stemnt = new WhileStemnt(yyvsp[-2].value,yyvsp[0].stemnt,*yyvsp[-4].loc);
            delete yyvsp[-4].loc;
            delete yyvsp[-3].loc;
            delete yyvsp[-1].loc;
        ;
    break;}
case 60:
#line 628 "gram.y"
{
            yyval.stemnt = new ForStemnt(yyvsp[-6].value,yyvsp[-4].value,yyvsp[-2].value,*yyvsp[-8].loc,yyvsp[0].stemnt);
            delete yyvsp[-8].loc;
            delete yyvsp[-7].loc;
            delete yyvsp[-5].loc;
            delete yyvsp[-3].loc;
            delete yyvsp[-1].loc;
        ;
    break;}
case 64:
#line 644 "gram.y"
{
            if (gProject->Parse_TOS->transUnit)
                yyval.label = gProject->Parse_TOS->parseCtxt->Mk_named_label(yyvsp[0].symbol,
                                gProject->Parse_TOS->transUnit->contxt.labels);
        ;
    break;}
case 65:
#line 652 "gram.y"
{
            yyval.label = new Label(yyvsp[0].value);
            delete yyvsp[-1].loc;
        ;
    break;}
case 66:
#line 657 "gram.y"
{
            yyval.label = new Label(yyvsp[-2].value,yyvsp[0].value);
            delete yyvsp[-3].loc;
            delete yyvsp[-1].loc;
        ;
    break;}
case 67:
#line 665 "gram.y"
{
            yyval.label = new Label(LT_Default);
            delete yyvsp[0].loc;
        ;
    break;}
case 69:
#line 682 "gram.y"
{
            yyval.value = new TrinaryExpr(yyvsp[-4].value,yyvsp[-2].value,yyvsp[0].value,*yyvsp[-3].loc);
            delete yyvsp[-3].loc;
            delete yyvsp[-1].loc;
        ;
    break;}
case 71:
#line 691 "gram.y"
{
            yyval.value = new AssignExpr(yyvsp[-1].assignOp,yyvsp[-2].value,yyvsp[0].value,yyvsp[-2].value->location);
        ;
    break;}
case 72:
#line 697 "gram.y"
{
            yyval.value = (Expression*) NULL;
        ;
    break;}
case 75:
#line 707 "gram.y"
{
           yyval.value = (Expression*) NULL;
        ;
    break;}
case 79:
#line 718 "gram.y"
{
            yyval.value = new BinaryExpr(BO_Or,yyvsp[-2].value,yyvsp[0].value,*yyvsp[-1].loc);
            delete yyvsp[-1].loc;
        ;
    break;}
case 81:
#line 726 "gram.y"
{
            yyval.value = new BinaryExpr(BO_And,yyvsp[-2].value,yyvsp[0].value,*yyvsp[-1].loc);
            delete yyvsp[-1].loc;
        ;
    break;}
case 82:
#line 733 "gram.y"
{
            yyval.value = new UnaryExpr(UO_Not,yyvsp[0].value,*yyvsp[-1].loc);
            delete yyvsp[-1].loc;
        ;
    break;}
case 84:
#line 741 "gram.y"
{
            yyval.value = new BinaryExpr(BO_BitOr,yyvsp[-2].value,yyvsp[0].value,*yyvsp[-1].loc);
            delete yyvsp[-1].loc;
        ;
    break;}
case 86:
#line 749 "gram.y"
{
            yyval.value = new BinaryExpr(BO_BitXor,yyvsp[-2].value,yyvsp[0].value,*yyvsp[-1].loc);
            delete yyvsp[-1].loc;
        ;
    break;}
case 88:
#line 757 "gram.y"
{
            yyval.value = new BinaryExpr(BO_BitAnd,yyvsp[-2].value,yyvsp[0].value,*yyvsp[-1].loc);
            delete yyvsp[-1].loc;
        ;
    break;}
case 89:
#line 764 "gram.y"
{
            yyval.value = new UnaryExpr(UO_BitNot,yyvsp[0].value,*yyvsp[-1].loc);
            delete yyvsp[-1].loc;
        ;
    break;}
case 91:
#line 772 "gram.y"
{
            yyval.value = new CastExpr(yyvsp[-2].type,yyvsp[0].value,*yyvsp[-3].loc);
            delete yyvsp[-3].loc;
            delete yyvsp[-1].loc;
        ;
    break;}
case 93:
#line 781 "gram.y"
{
            yyval.value = new RelExpr(yyvsp[-1].relOp,yyvsp[-2].value,yyvsp[0].value,yyvsp[-2].value->location);
        ;
    break;}
case 95:
#line 788 "gram.y"
{
            yyval.value = new RelExpr(yyvsp[-1].relOp,yyvsp[-2].value,yyvsp[0].value,yyvsp[-2].value->location);
        ;
    break;}
case 97:
#line 795 "gram.y"
{
            yyval.value = new BinaryExpr(yyvsp[-1].binOp,yyvsp[-2].value,yyvsp[0].value,yyvsp[-2].value->location);
        ;
    break;}
case 99:
#line 802 "gram.y"
{
            yyval.value = new BinaryExpr(yyvsp[-1].binOp,yyvsp[-2].value,yyvsp[0].value,yyvsp[-2].value->location);
        ;
    break;}
case 101:
#line 809 "gram.y"
{
            yyval.value = new BinaryExpr(yyvsp[-1].binOp,yyvsp[-2].value,yyvsp[0].value,yyvsp[-2].value->location);
        ;
    break;}
case 112:
#line 827 "gram.y"
{
            yyval.value = new SizeofExpr(yyvsp[-1].type,*yyvsp[-3].loc);
            delete yyvsp[-3].loc;
            delete yyvsp[-2].loc;
            delete yyvsp[0].loc;
        ;
    break;}
case 113:
#line 834 "gram.y"
{
            yyval.value = new SizeofExpr(yyvsp[0].value,*yyvsp[-1].loc);
            delete yyvsp[-1].loc;
        ;
    break;}
case 114:
#line 841 "gram.y"
{
            yyval.value = new UnaryExpr(UO_Minus,yyvsp[0].value,HERE);
        ;
    break;}
case 115:
#line 847 "gram.y"
{
            /* Unary plus is an ISO addition (for symmetry) - ignore it */
            yyval.value = yyvsp[0].value;
        ;
    break;}
case 116:
#line 854 "gram.y"
{
            yyval.value = new UnaryExpr(UO_AddrOf,yyvsp[0].value,*yyvsp[-1].loc);
            delete yyvsp[-1].loc;
        ;
    break;}
case 117:
#line 861 "gram.y"
{
            yyval.value = new UnaryExpr(UO_Deref,yyvsp[0].value,HERE);
        ;
    break;}
case 118:
#line 867 "gram.y"
{
            yyval.value = new UnaryExpr(UO_PreInc,yyvsp[0].value,*yyvsp[-1].loc);
            delete yyvsp[-1].loc;
        ;
    break;}
case 119:
#line 874 "gram.y"
{
            yyval.value = new UnaryExpr(UO_PreDec,yyvsp[0].value,*yyvsp[-1].loc);
            delete yyvsp[-1].loc;
        ;
    break;}
case 121:
#line 882 "gram.y"
{
            yyval.value = new BinaryExpr(BO_Comma,yyvsp[-2].value,yyvsp[0].value,*yyvsp[-1].loc);
            delete yyvsp[-1].loc;
        ;
    break;}
case 122:
#line 889 "gram.y"
{
            if (yyvsp[0].symbol->entry == NULL && gProject->warn_variable)
            {
                yywarn("Undeclared variable");
            }

            yyval.value = new Variable(yyvsp[0].symbol, HERE);
        ;
    break;}
case 124:
#line 899 "gram.y"
{
            yyval.value = yyvsp[0].consValue;
        ;
    break;}
case 125:
#line 905 "gram.y"
{
            yyval.value = yyvsp[-1].value;
            delete yyvsp[-2].loc;
            delete yyvsp[0].loc;
        ;
    break;}
case 126:
#line 911 "gram.y"
{
            yyval.value = (Expression*) NULL;
            delete yyvsp[-2].loc;
            delete yyvsp[0].loc;
        ;
    break;}
case 133:
#line 927 "gram.y"
{
            yyval.value = new IndexExpr(yyvsp[-3].value,yyvsp[-1].value,*yyvsp[-2].loc);
            delete yyvsp[-2].loc;
            delete yyvsp[0].loc;
        ;
    break;}
case 136:
#line 939 "gram.y"
{
            yyval.value = new UnaryExpr(UO_PostInc,yyvsp[-1].value,*yyvsp[0].loc);
            delete yyvsp[0].loc;
        ;
    break;}
case 137:
#line 946 "gram.y"
{
            yyval.value = new UnaryExpr(UO_PostDec,yyvsp[-1].value,*yyvsp[0].loc);
            delete yyvsp[0].loc;
        ;
    break;}
case 139:
#line 956 "gram.y"
{
            Variable *var = new Variable(yyvsp[0].symbol,*yyvsp[-1].loc);
            BinaryExpr *be = new BinaryExpr(BO_Member,yyvsp[-2].value,var,*yyvsp[-1].loc);
            delete yyvsp[-1].loc;
            yyval.value = be;

            // Lookup the component in its struct
            // if possible.
            if (yyvsp[-2].value->etype == ET_Variable)
            {
                Variable  *var = (Variable*) yyvsp[-2].value;
                Symbol    *varName = var->name;
                SymEntry  *entry = varName->entry;

                if (entry && entry->uVarDecl)
                {
                    entry->uVarDecl->lookup(yyvsp[0].symbol);
                }
            }
        ;
    break;}
case 140:
#line 979 "gram.y"
{
            Variable *var = new Variable(yyvsp[0].symbol,*yyvsp[-1].loc);
            BinaryExpr *be = new BinaryExpr(BO_PtrMember,yyvsp[-2].value,var,*yyvsp[-1].loc);
            delete yyvsp[-1].loc;
            yyval.value = be;

            // Lookup the component in its struct
            // if possible.
            if (yyvsp[-2].value->etype == ET_Variable)
            {
                Variable  *var = (Variable*) yyvsp[-2].value;
                Symbol    *varName = var->name;
                SymEntry  *entry = varName->entry;

                if (entry && entry->uVarDecl)
                {
                    entry->uVarDecl->lookup(yyvsp[0].symbol);
                }
            }
        ;
    break;}
case 141:
#line 1002 "gram.y"
{
            FunctionCall* fc = new FunctionCall(yyvsp[-3].value,*yyvsp[-2].loc);

            /* add function args */
            fc->addArgs(ReverseList(yyvsp[-1].value));

            delete yyvsp[-2].loc;
            delete yyvsp[0].loc;
            yyval.value = fc;
        ;
    break;}
case 142:
#line 1015 "gram.y"
{
            yyval.value = (Expression*) NULL;
        ;
    break;}
case 145:
#line 1023 "gram.y"
{
            yyval.value = yyvsp[0].value;
            yyval.value->next = yyvsp[-2].value;

            delete yyvsp[-1].loc;
        ;
    break;}
case 163:
#line 1068 "gram.y"
{
            if (gProject->Parse_TOS->transUnit)
                gProject->Parse_TOS->transUnit->contxt.ReEnterScope();
        ;
    break;}
case 164:
#line 1073 "gram.y"
{
            yyval.decl = (Decl*) NULL;
            if (gProject->Parse_TOS->transUnit)
                gProject->Parse_TOS->transUnit->contxt.ExitScope();
        ;
    break;}
case 165:
#line 1079 "gram.y"
{
            if (gProject->Parse_TOS->transUnit)
                gProject->Parse_TOS->transUnit->contxt.ReEnterScope();
            gProject->Parse_TOS->parseCtxt->ResetDeclCtxt();
        ;
    break;}
case 166:
#line 1084 "gram.y"
{   gProject->Parse_TOS->parseCtxt->SetVarParam(1, !gProject->Parse_TOS->err_top_level, 0); 
            gProject->Parse_TOS->parseCtxt->SetIsKnR(true); 
        ;
    break;}
case 167:
#line 1088 "gram.y"
{   yyval.decl = yyvsp[0].decl;
            gProject->Parse_TOS->parseCtxt->SetIsKnR(false); 
            gProject->Parse_TOS->parseCtxt->SetVarParam(0, !gProject->Parse_TOS->err_top_level, 1); 
            
            // Exit, but will allow re-enter for a function.
            // Hack, to handle parameters being in the function's scope.
            if (gProject->Parse_TOS->transUnit)
                gProject->Parse_TOS->transUnit->contxt.ExitScope(true);
        ;
    break;}
case 168:
#line 1100 "gram.y"
{
            if (gProject->Parse_TOS->transUnit)
                gProject->Parse_TOS->transUnit->contxt.EnterScope();
            gProject->Parse_TOS->parseCtxt->ResetDeclCtxt();
        ;
    break;}
case 169:
#line 1106 "gram.y"
{
            yyval.decl = (Decl*) NULL;
        ;
    break;}
case 170:
#line 1110 "gram.y"
{
            if (gProject->Parse_TOS->transUnit)
                gProject->Parse_TOS->transUnit->contxt.EnterScope();
            gProject->Parse_TOS->parseCtxt->ResetDeclCtxt();
        ;
    break;}
case 171:
#line 1115 "gram.y"
{   gProject->Parse_TOS->parseCtxt->SetVarParam(0, !gProject->Parse_TOS->err_top_level, 0); 
        ;
    break;}
case 172:
#line 1118 "gram.y"
{   yyval.decl = yyvsp[0].decl;
            gProject->Parse_TOS->parseCtxt->SetVarParam(0, !gProject->Parse_TOS->err_top_level, 0);
        ;
    break;}
case 173:
#line 1124 "gram.y"
{
            yyval.decl = yyvsp[-1].decl;
            delete yyvsp[0].loc;
        ;
    break;}
case 174:
#line 1129 "gram.y"
{
            yyval.decl = yyvsp[-2].decl;

			Decl*	appendDecl = yyvsp[-2].decl;
			while (appendDecl->next != NULL)
				appendDecl = appendDecl->next;

            appendDecl->next = yyvsp[0].decl;
            delete yyvsp[-1].loc;
        ;
    break;}
case 175:
#line 1142 "gram.y"
{
            yyval.declStemnt = new DeclStemnt(*yyvsp[0].loc);
            yyval.declStemnt->addDecls(ReverseList(yyvsp[-1].decl));
            delete yyvsp[0].loc;
        ;
    break;}
case 176:
#line 1149 "gram.y"
{
            yyval.declStemnt = new DeclStemnt(*yyvsp[0].loc);
            yyval.declStemnt->addDecls(ReverseList(yyvsp[-1].decl));
            delete yyvsp[0].loc;
        ;
    break;}
case 177:
#line 1157 "gram.y"
{
            assert (gProject->Parse_TOS->err_top_level ||
                    yyvsp[-1].base == gProject->Parse_TOS->parseCtxt->curCtxt->decl_specs);
            gProject->Parse_TOS->parseCtxt->ResetDeclCtxt();
            
            yywarn("old-style declaration or incorrect type");

            gProject->Parse_TOS->possibleType = true;
            yyval.decl = yyvsp[0].decl;

            if (yyval.decl == NULL)
            {
                yyval.decl = new Decl(yyvsp[-1].base);
            }
        ;
    break;}
case 178:
#line 1175 "gram.y"
{
            assert (gProject->Parse_TOS->err_top_level ||
                    yyvsp[-1].base == gProject->Parse_TOS->parseCtxt->curCtxt->decl_specs);
            gProject->Parse_TOS->parseCtxt->ResetDeclCtxt();            
            
            gProject->Parse_TOS->possibleType = true;
            yyval.decl = yyvsp[0].decl;
            
            if (yyval.decl == NULL)
            {
                yyval.decl = new Decl(yyvsp[-1].base);
            }
        ;
    break;}
case 179:
#line 1195 "gram.y"
{
            yyval.base = new BaseType(BT_Int);
            gProject->Parse_TOS->parseCtxt->SetDeclCtxt(yyval.base);
        ;
    break;}
case 182:
#line 1214 "gram.y"
{   
            gProject->Parse_TOS->parseCtxt->PushCtxt();
            gProject->Parse_TOS->parseCtxt->ResetVarParam();
        ;
    break;}
case 183:
#line 1219 "gram.y"
{
            yyval.type = yyvsp[0].type;
            gProject->Parse_TOS->parseCtxt->PopCtxt(false);
        ;
    break;}
case 184:
#line 1226 "gram.y"
{
            assert (yyvsp[0].base == gProject->Parse_TOS->parseCtxt->curCtxt->decl_specs);
            
            gProject->Parse_TOS->possibleType = true;
            yyval.type = yyvsp[0].base;
            if (yyval.type->isFunction())
                if(yyerr ("Function type not allowed as type name"))
                  YYERROR;
        ;
    break;}
case 185:
#line 1236 "gram.y"
{
            assert (yyvsp[-1].base == gProject->Parse_TOS->parseCtxt->curCtxt->decl_specs);
            
            gProject->Parse_TOS->possibleType = true;
            yyval.type = yyvsp[0].type;
            
            Type * extended = yyval.type->extend(yyvsp[-1].base);
            if (yyval.type->isFunction())
            {
                if(yyerr ("Function type not allowed as type name"))
                  YYERROR;
            }
            else if (extended && 
                yyvsp[-1].base && yyvsp[-1].base->isFunction() && 
                ! extended->isPointer())
            {
                if(yyerr ("Wrong type combination"))
                  YYERROR;
            }
        ;
    break;}
case 186:
#line 1264 "gram.y"
{
            gProject->Parse_TOS->parseCtxt->SetDeclCtxt(yyval.base);
        ;
    break;}
case 193:
#line 1280 "gram.y"
{
            if (! gProject->Parse_TOS->transUnit ||
                gProject->Parse_TOS->transUnit->contxt.syms->current->level >= FUNCTION_SCOPE)
                 yyval.storage = yyvsp[0].storage ;             
             else
                 yyval.storage = ST_None ;              
        ;
    break;}
case 195:
#line 1293 "gram.y"
{
            yyval.base = (BaseType*) NULL;
        ;
    break;}
case 197:
#line 1300 "gram.y"
{
            yyval.base = yyvsp[0].base;

            if (!yyval.base)
            {
                yyval.base = new BaseType();
            }

            if (yyvsp[-1].storage == ST_None)
            {
                 if(yyerr("Invalid use of local storage type"))
                   YYERROR;
            }
            else if (yyval.base->storage != ST_None)             
                 yywarn("Overloading previous storage type specification");
            else
                 yyval.base->storage = yyvsp[-1].storage;
        ;
    break;}
case 198:
#line 1318 "gram.y"
{ gProject->Parse_TOS->possibleType = false; ;
    break;}
case 199:
#line 1319 "gram.y"
{
            yyval.base = yyvsp[-2].base;

            if (yyvsp[0].base)
            {
                if ((yyvsp[0].base->typemask & BT_Long)
                    && (yyval.base->typemask & BT_Long))
                {
                   // long long : A likely C9X addition 
                   yyval.base->typemask &= ~BT_Long;
                   yyvsp[0].base->typemask &= ~BT_Long;
                   yyval.base->typemask |= yyvsp[0].base->typemask;
                   yyval.base->typemask |=  BT_LongLong;
                }
                else
                    yyval.base->typemask |= yyvsp[0].base->typemask;

                if (yyvsp[0].base->storage != ST_None)
                    yyval.base->storage = yyvsp[0].base->storage;

                // delete $3;
            }

            /*
            std::cout << "In decl_spec: ";
            $$->printBase(std::cout,0);
            if ($$->storage == ST_Typedef)
                std::cout << "(is a typedef)";
            std::cout << std::endl;
            */
        ;
    break;}
case 200:
#line 1351 "gram.y"
{
            yyval.base = yyvsp[0].base;

            if (!yyval.base)
            {
                yyval.base = new BaseType();
            }

            if ((yyval.base->qualifier & yyvsp[-1].typeQual) != TQ_None)
                yywarn("qualifier already specified");  
                              
            yyval.base->qualifier |= yyvsp[-1].typeQual;

        ;
    break;}
case 201:
#line 1371 "gram.y"
{
           yyval.base = (BaseType*) NULL;
        ;
    break;}
case 203:
#line 1377 "gram.y"
{ gProject->Parse_TOS->possibleType = false; ;
    break;}
case 204:
#line 1378 "gram.y"
{
            yyval.base = yyvsp[-2].base;

            if (yyvsp[0].base)
            {
                yyval.base->typemask |= yyvsp[0].base->typemask;
                // delete $3;
            }
        ;
    break;}
case 205:
#line 1388 "gram.y"
{
            yyval.base = yyvsp[0].base;

            if (!yyval.base)
            {
                yyval.base = new BaseType();
            }

            if ((yyval.base->qualifier & yyvsp[-1].typeQual) != TQ_None)
                yywarn("qualifier already specified");
            yyval.base->qualifier |= yyvsp[-1].typeQual;
        ;
    break;}
case 206:
#line 1403 "gram.y"
{
            gProject->Parse_TOS->parseCtxt->SetDeclCtxt(yyval.base);
        ;
    break;}
case 207:
#line 1412 "gram.y"
{
           yyvsp[0].decl->extend(gProject->Parse_TOS->parseCtxt->UseDeclCtxt());
        ;
    break;}
case 208:
#line 1416 "gram.y"
{
           yyvsp[-2].decl->attrib = yyvsp[0].gccAttrib;
           yyval.decl = yyvsp[-2].decl;
        ;
    break;}
case 210:
#line 1424 "gram.y"
{
           yyvsp[-2].decl->initializer = yyvsp[0].value;
           yyval.decl = yyvsp[-2].decl;
        ;
    break;}
case 211:
#line 1431 "gram.y"
{
          yyval.decl = (Decl*) NULL;
        ;
    break;}
case 214:
#line 1441 "gram.y"
{
            yyval.decl = yyvsp[0].decl;
        ;
    break;}
case 215:
#line 1445 "gram.y"
{
            yyval.decl = yyvsp[-2].decl;

			Decl*	appendDecl = yyvsp[-2].decl;
			while (appendDecl->next != NULL)
				appendDecl = appendDecl->next;

            appendDecl->next = yyvsp[0].decl;
            delete yyvsp[-1].loc;
        ;
    break;}
case 217:
#line 1463 "gram.y"
{
            yyval.arrayConst = new ArrayConstant(NoLocation);
            yyval.arrayConst->addElement(yyvsp[0].value);
        ;
    break;}
case 218:
#line 1468 "gram.y"
{
            yyval.arrayConst = yyvsp[-2].arrayConst;
            yyval.arrayConst->addElement(yyvsp[0].value);
            delete yyvsp[-1].loc;
        ;
    break;}
case 220:
#line 1477 "gram.y"
{
            yyval.value = yyvsp[-2].arrayConst;
            delete yyvsp[-3].loc;
            delete yyvsp[0].loc;
        ;
    break;}
case 221:
#line 1485 "gram.y"
{
            yyval.loc = (Location*) NULL;
        ;
    break;}
case 222:
#line 1489 "gram.y"
{
            delete yyvsp[0].loc;
            yyval.loc = (Location*) NULL;
        ;
    break;}
case 227:
#line 1509 "gram.y"
{
            yyval.typeQual = yyvsp[-1].typeQual | yyvsp[0].typeQual;
            if ((yyvsp[0].typeQual & yyvsp[-1].typeQual) != TQ_None)
                yywarn("qualifier already specified");                               
        ;
    break;}
case 228:
#line 1517 "gram.y"
{
            yyval.typeQual = TQ_None;
        ;
    break;}
case 251:
#line 1551 "gram.y"
{
            yyval.base = new BaseType(BT_UserType);
            yyval.base->typeName = yyvsp[0].symbol;
        ;
    break;}
case 252:
#line 1558 "gram.y"
{
            assert ((! yyval.symbol->entry) || 
                    yyval.symbol->entry->IsTagDecl()) ;
        ;
    break;}
case 253:
#line 1566 "gram.y"
{
            if (gProject->Parse_TOS->transUnit)
                yyval.base = gProject->Parse_TOS->parseCtxt->Mk_tag_ref(yyvsp[-1].typeSpec, yyvsp[0].symbol,
                                                                gProject->Parse_TOS->transUnit->contxt.tags);
            else
                yyval.base = NULL;                                         
        ;
    break;}
case 254:
#line 1576 "gram.y"
{
            if (gProject->Parse_TOS->transUnit)
                yyval.base = gProject->Parse_TOS->parseCtxt->Mk_tag_ref(yyvsp[-1].typeSpec, yyvsp[0].symbol,
                                                                gProject->Parse_TOS->transUnit->contxt.tags);
            else
                yyval.base = NULL;                                         
        ;
    break;}
case 255:
#line 1586 "gram.y"
{
            if (gProject->Parse_TOS->transUnit)
                yyval.base = gProject->Parse_TOS->parseCtxt->Mk_tag_ref(yyvsp[-1].typeSpec, yyvsp[0].symbol,
                                                                gProject->Parse_TOS->transUnit->contxt.tags);
            else
                yyval.base = NULL;                                         
        ;
    break;}
case 256:
#line 1596 "gram.y"
{
            if (gProject->Parse_TOS->transUnit)
                yyval.base = gProject->Parse_TOS->parseCtxt->Mk_tag_def(yyvsp[-1].typeSpec, yyvsp[0].symbol,
                                                            gProject->Parse_TOS->transUnit->contxt.tags);
            else
                yyval.base = NULL;                                         
        ;
    break;}
case 257:
#line 1606 "gram.y"
{
            yyval.base = new BaseType(yyvsp[-1].strDef);
            yyvsp[-1].strDef->_isUnion = false;
            delete yyvsp[-2].loc;
            delete yyvsp[0].loc;
        ;
    break;}
case 258:
#line 1613 "gram.y"
{
            yyval.base = yyvsp[-3].base;
            assert (! yyval.base->stDefn);
            yyval.base->stDefn = yyvsp[-1].strDef;
            yyvsp[-1].strDef->tag = yyvsp[-3].base->tag->dup();
            yyvsp[-1].strDef->_isUnion = false;

            // Overload the incomplete definition
            yyval.base->tag->entry->uStructDef = yyval.base ;
            
//             std::cout << "struct/union/enum_type_define:"
//                          "The definition of:"
//                       << "(uStructDef:" << $1->tag->entry->uStructDef << ")"
//                       << "(uStructDef->stDefn:" << $1->tag->entry->uStructDef->stDefn << ")"
//                       << "(" << $1->tag->entry << ")" << $1->tag->name  << "$" ;
//             $1->tag->entry->scope->ShowScopeId(std::cout);
//             std::cout << " has been completed" << endl; 
            
            delete yyvsp[-2].loc;
            delete yyvsp[0].loc;
        ;
    break;}
case 259:
#line 1637 "gram.y"
{
            if (gProject->Parse_TOS->transUnit)
                yyval.base = gProject->Parse_TOS->parseCtxt->Mk_tag_def(yyvsp[-1].typeSpec, yyvsp[0].symbol,
                                                            gProject->Parse_TOS->transUnit->contxt.tags);
            else
              yyval.base = NULL ;
        ;
    break;}
case 260:
#line 1647 "gram.y"
{
            yyval.base = new BaseType(yyvsp[-1].strDef);
            yyvsp[-1].strDef->_isUnion = true;

            delete yyvsp[-2].loc;
            delete yyvsp[0].loc;
        ;
    break;}
case 261:
#line 1655 "gram.y"
{
            yyval.base = yyvsp[-3].base;
            assert (! yyval.base->stDefn);
            yyval.base->stDefn = yyvsp[-1].strDef;
            yyvsp[-1].strDef->tag = yyvsp[-3].base->tag->dup();
            yyvsp[-1].strDef->_isUnion = true;

            // Overload the incomplete definition
            yyval.base->tag->entry->uStructDef = yyval.base ;
            
//             std::cout << "struct/union/enum_type_define:"
//                          "The definition of:"
//                       << "(uStructDef:" << $1->tag->entry->uStructDef << ")"
//                       << "(uStructDef->stDefn:" << $1->tag->entry->uStructDef->stDefn << ")"
//                       << "(" << $1->tag->entry << ")" << $1->tag->name  << "$" ;
//             $1->tag->entry->scope->ShowScopeId(std::cout);
//             std::cout << " has been completed" << endl; 
            
            delete yyvsp[-2].loc;
            delete yyvsp[0].loc;
 
        ;
    break;}
case 262:
#line 1680 "gram.y"
{
            if (gProject->Parse_TOS->transUnit)
                yyval.base = gProject->Parse_TOS->parseCtxt->Mk_tag_def(yyvsp[-1].typeSpec,yyvsp[0].symbol,
                                                            gProject->Parse_TOS->transUnit->contxt.tags);
            else
              yyval.base = NULL;
        ;
    break;}
case 263:
#line 1690 "gram.y"
{
            yyval.base = new BaseType(yyvsp[-1].enDef);

            delete yyvsp[-2].loc;
            delete yyvsp[0].loc;
        ;
    break;}
case 264:
#line 1697 "gram.y"
{
            yyval.base = yyvsp[-3].base;
            assert (! yyval.base->enDefn);
            yyval.base->enDefn = yyvsp[-1].enDef;
            yyvsp[-1].enDef->tag = yyvsp[-3].base->tag->dup();

            // Overload the incomplete definition
            yyval.base->tag->entry->uStructDef = yyval.base ;
            
//             std::cout << "struct/union/enum_type_define:"
//                          "The definition of:"
//                       << "(uStructDef:" << $1->tag->entry->uStructDef << ")"
//                       << "(uStructDef->stDefn:" << $1->tag->entry->uStructDef->stDefn << ")"
//                       << "(" << $1->tag->entry << ")" << $1->tag->name  << "$" ;
//             $1->tag->entry->scope->ShowScopeId(std::cout);
//             std::cout << " has been completed" << endl; 
            
            delete yyvsp[-2].loc;
            delete yyvsp[0].loc;
        ;
    break;}
case 265:
#line 1720 "gram.y"
{  yyval.strDef = new StructDef();
           yywarn("ANSI/ISO C prohibits empty struct/union");
        ;
    break;}
case 267:
#line 1727 "gram.y"
{  yyval.enDef = new EnumDef();
           yywarn("ANSI/ISO C prohibits empty enum");
        ;
    break;}
case 268:
#line 1731 "gram.y"
{  yyval.enDef = yyvsp[-1].enDef;
        ;
    break;}
case 269:
#line 1736 "gram.y"
{
            yyval.loc = NULL;
        ;
    break;}
case 270:
#line 1740 "gram.y"
{
          yywarn("Trailing comma in enum type definition");
        ;
    break;}
case 272:
#line 1753 "gram.y"
{
            yyval.enDef = new EnumDef();
            yyval.enDef->addElement(yyvsp[0].enConst);
        ;
    break;}
case 273:
#line 1758 "gram.y"
{
            yyval.enDef = yyvsp[-2].enDef;
            yyval.enDef->addElement(yyvsp[0].enConst);
            delete yyvsp[-1].loc;
        ;
    break;}
case 274:
#line 1766 "gram.y"
{
            yyval.enConst = new EnumConstant(yyvsp[0].symbol,NULL,HERE);
            if (gProject->Parse_TOS->transUnit)
            {
              if (gProject->Parse_TOS->transUnit->contxt.syms->IsDefined(yyvsp[0].symbol->name))
              {
                 if(yyerr("Duplicate enumeration constant"))
                   YYERROR;
              }
                 
              yyvsp[0].symbol->entry = gProject->Parse_TOS->transUnit->contxt.syms->Insert(
                                  mk_enum_const(yyvsp[0].symbol->name, yyval.enConst));
            }
        ;
    break;}
case 275:
#line 1781 "gram.y"
{
            yyval.enConst = new EnumConstant(yyvsp[-2].symbol,yyvsp[0].value,HERE);
            if (gProject->Parse_TOS->transUnit)
            {
              if (gProject->Parse_TOS->transUnit->contxt.syms->IsDefined(yyvsp[-2].symbol->name))
              {
                 if(yyerr("Duplicate enumeration constant"))
                   YYERROR;
              }
                 
              yyvsp[-2].symbol->entry = gProject->Parse_TOS->transUnit->contxt.syms->Insert(
                                  mk_enum_const(yyvsp[-2].symbol->name, yyval.enConst));
            }
        ;
    break;}
case 277:
#line 1804 "gram.y"
{
            if (gProject->Parse_TOS->transUnit)
                gProject->Parse_TOS->transUnit->contxt.EnterScope();
            gProject->Parse_TOS->parseCtxt->PushCtxt();
        ;
    break;}
case 278:
#line 1809 "gram.y"
{
            assert (!gProject->Parse_TOS->err_top_level || gProject->Parse_TOS->possibleType);
             /* Safety precaution! */
             gProject->Parse_TOS->possibleType=true;
        ;
    break;}
case 279:
#line 1815 "gram.y"
{
            gProject->Parse_TOS->parseCtxt->PopCtxt(false);
            if (gProject->Parse_TOS->transUnit)
                gProject->Parse_TOS->transUnit->contxt.ExitScope();
            yyval.strDef = yyvsp[0].strDef ;
        ;
    break;}
case 280:
#line 1824 "gram.y"
{
            yyval.strDef = new StructDef();
            yyval.strDef->addComponent(ReverseList(yyvsp[-1].decl));
            delete yyvsp[0].loc;
        ;
    break;}
case 281:
#line 1830 "gram.y"
{
            // A useful gcc extension:
            //   naked semicolons in struct/union definitions. 
            yyval.strDef = yyvsp[-1].strDef;
            yywarn ("Empty declaration");
            delete yyvsp[0].loc;
        ;
    break;}
case 282:
#line 1838 "gram.y"
{
            yyval.strDef = yyvsp[-2].strDef;
            yyval.strDef->addComponent(ReverseList(yyvsp[-1].decl));
            delete yyvsp[0].loc;
        ;
    break;}
case 283:
#line 1846 "gram.y"
{
            gProject->Parse_TOS->possibleType = true;
            yyval.decl = yyvsp[0].decl;
        ;
    break;}
case 284:
#line 1851 "gram.y"
{
            gProject->Parse_TOS->possibleType = true;
            yyval.decl = new Decl (yyvsp[0].base);
            yywarn ("No field declarator");
        ;
    break;}
case 286:
#line 1865 "gram.y"
{   gProject->Parse_TOS->parseCtxt->SetIsFieldId(true); 
        ;
    break;}
case 287:
#line 1868 "gram.y"
{
            yyval.decl = yyvsp[-1].decl;
            yyval.decl->attrib = yyvsp[0].gccAttrib;
        ;
    break;}
case 288:
#line 1873 "gram.y"
{   gProject->Parse_TOS->parseCtxt->SetIsFieldId(true); 
        ;
    break;}
case 289:
#line 1876 "gram.y"
{
            yyval.decl = yyvsp[-1].decl;
            yyval.decl->attrib = yyvsp[0].gccAttrib;
            yyval.decl->next = yyvsp[-4].decl;
            delete yyvsp[-3].loc;
        ;
    break;}
case 290:
#line 1885 "gram.y"
{
           gProject->Parse_TOS->parseCtxt->SetIsFieldId(false); 
           Type * decl = gProject->Parse_TOS->parseCtxt->UseDeclCtxt();
           Type * extended = yyval.decl->extend(decl);
           if (yyval.decl->form &&
               yyval.decl->form->isFunction())
           {
               if(yyerr ("Function type not allowed as field"))
                 YYERROR;
           }
           else if (extended && 
               decl && decl->isFunction() && 
               ! extended->isPointer())
               if(yyerr ("Wrong type combination"))
                 YYERROR;
                
        ;
    break;}
case 291:
#line 1903 "gram.y"
{
           Type * decl = gProject->Parse_TOS->parseCtxt->UseDeclCtxt();
           yyval.decl->extend(decl);
           if (! decl)
           {
               if(yyerr ("No type specifier for bit field"))
                 YYERROR;
           }
           else if (!yyval.decl->form)
           {
               if(yyerr ("Wrong type combination"))
                 YYERROR;
           }
        ;
    break;}
case 293:
#line 1923 "gram.y"
{   gProject->Parse_TOS->parseCtxt->SetIsFieldId(false); 
        ;
    break;}
case 294:
#line 1926 "gram.y"
{
            BitFieldType  *bf = new BitFieldType(yyvsp[0].value);
            yyval.decl = yyvsp[-3].decl;

            if (yyval.decl == NULL)
            {
                yyval.decl = new Decl(bf);
            }
            else
            {
                bf->subType = yyval.decl->form;
                yyval.decl->form = bf;
            }
        ;
    break;}
case 296:
#line 1946 "gram.y"
{
           yyval.decl = (Decl*) NULL;
        ;
    break;}
case 298:
#line 1957 "gram.y"
{
            gProject->Parse_TOS->parseCtxt->Mk_declarator (yyval.decl);
        ;
    break;}
case 299:
#line 1963 "gram.y"
{
            gProject->Parse_TOS->parseCtxt->Mk_func_declarator (yyval.decl);
        ;
    break;}
case 300:
#line 1969 "gram.y"
{
            yyval.decl = yyvsp[0].decl;
            yyval.decl->extend(yyvsp[-1].ptr);
        ;
    break;}
case 303:
#line 1980 "gram.y"
{  if (gProject->Parse_TOS->transUnit)
                yyval.decl = gProject->Parse_TOS->parseCtxt->Mk_direct_declarator_reentrance (yyvsp[0].symbol,
                gProject->Parse_TOS->transUnit->contxt.syms);
        ;
    break;}
case 304:
#line 1985 "gram.y"
{
            yyval.decl = yyvsp[-1].decl;
            delete yyvsp[-2].loc ;
            delete yyvsp[0].loc ;
        ;
    break;}
case 306:
#line 1992 "gram.y"
{
            yyval.decl = yyvsp[-3].decl;
            FunctionType * ft = new FunctionType(ReverseList(yyvsp[-1].decl));
            Type * extended = yyval.decl->extend(ft);
            if (extended && ! extended->isPointer())
                if(yyerr ("Wrong type combination"))
                  YYERROR;
                
            delete yyvsp[-2].loc ;
            delete yyvsp[0].loc ;
            // Exit, but will allow re-enter for a function.
            // Hack, to handle parameters being in the function's scope.
            if (gProject->Parse_TOS->transUnit)
                gProject->Parse_TOS->transUnit->contxt.ExitScope(true);

        ;
    break;}
case 307:
#line 2009 "gram.y"
{
            yyval.decl = yyvsp[-3].decl;
            FunctionType * ft = new FunctionType(ReverseList(yyvsp[-1].decl));
            Type * extended = yyval.decl->extend(ft);
            if (extended && ! extended->isPointer())
                if(yyerr ("Wrong type combination"))
                  YYERROR;

            delete yyvsp[-2].loc ;
            delete yyvsp[0].loc ;
            // Exit, but will allow re-enter for a function.
            // Hack, to handle parameters being in the function's scope.
            if (gProject->Parse_TOS->transUnit)
                gProject->Parse_TOS->transUnit->contxt.ExitScope(true);

        ;
    break;}
case 308:
#line 2026 "gram.y"
{
            yyval.decl = yyvsp[-2].decl;

			if (yyval.decl != NULL)
			{
				FunctionType* ft = new FunctionType();
				Type* extended = yyval.decl->extend(ft);
				if (extended && ! extended->isPointer())
           	 	    if(yyerr ("Wrong type combination"))
                              YYERROR;
			}
            
            delete yyvsp[-1].loc ;
            delete yyvsp[0].loc ;
            if (gProject->Parse_TOS->transUnit)
            {
                gProject->Parse_TOS->transUnit->contxt.EnterScope();
                // Exit, but will allow re-enter for a function.
                // Hack, to handle parameters being in the function's scope.
                gProject->Parse_TOS->transUnit->contxt.ExitScope(true);
            }
        ;
    break;}
case 309:
#line 2051 "gram.y"
{
            yyval.decl = yyvsp[-3].decl;
            ArrayType * at = new ArrayType(yyvsp[-1].value);
            Type * extended = yyval.decl->extend(at);
            if (extended && 
                extended->isFunction())
                if(yyerr ("Wrong type combination"))
                  YYERROR;
              
            delete yyvsp[-2].loc ;
            delete yyvsp[0].loc ;
        ;
    break;}
case 310:
#line 2069 "gram.y"
{
            yyval.ptr = new PtrType(yyvsp[0].typeQual);    
        ;
    break;}
case 312:
#line 2076 "gram.y"
{
            yyval.ptr = yyvsp[0].ptr;
            yyval.ptr->subType = yyvsp[-1].ptr;
        ;
    break;}
case 314:
#line 2089 "gram.y"
{  gProject->Parse_TOS->parseCtxt->IncrVarParam(1);
          if (gProject->Parse_TOS->transUnit)
              gProject->Parse_TOS->transUnit->contxt.EnterScope();
          gProject->Parse_TOS->parseCtxt->PushCtxt();
        ;
    break;}
case 315:
#line 2095 "gram.y"
{
          // Exit, but will allow re-enter for a function.
          // Hack, to handle parameters being in the function's scope.
          gProject->Parse_TOS->parseCtxt->PopCtxt(true);
          gProject->Parse_TOS->parseCtxt->IncrVarParam(-1);
          yyval.decl = yyvsp[0].decl;
       ;
    break;}
case 316:
#line 2105 "gram.y"
{  if (gProject->Parse_TOS->transUnit)
               yyval.decl = gProject->Parse_TOS->parseCtxt->Mk_direct_declarator_reentrance (yyvsp[0].symbol,
                gProject->Parse_TOS->transUnit->contxt.syms);
        ;
    break;}
case 317:
#line 2110 "gram.y"
{  yyval.decl = yyvsp[-2].decl;
           if (gProject->Parse_TOS->transUnit)
           {
              yyval.decl = gProject->Parse_TOS->parseCtxt->Mk_direct_declarator_reentrance (yyvsp[0].symbol,
                gProject->Parse_TOS->transUnit->contxt.syms);
              yyval.decl->next = yyvsp[-2].decl;
           }
        ;
    break;}
case 319:
#line 2126 "gram.y"
{
            /* Convert a TYPEDEF_NAME back into a normal IDENT */
            yyval.symbol = yyvsp[0].symbol;
            yyval.symbol->entry = (SymEntry*) NULL;
        ;
    break;}
case 322:
#line 2147 "gram.y"
{
           yyval.decl = (Decl*) NULL;
        ;
    break;}
case 323:
#line 2151 "gram.y"
{ gProject->Parse_TOS->parseCtxt->IncrVarParam(1); 
        ;
    break;}
case 324:
#line 2154 "gram.y"
{ gProject->Parse_TOS->parseCtxt->IncrVarParam(-1); 
           yyval.decl = yyvsp[0].decl;
        ;
    break;}
case 325:
#line 2160 "gram.y"
{   gProject->Parse_TOS->parseCtxt->IncrVarParam(1);
            if (gProject->Parse_TOS->transUnit)
                gProject->Parse_TOS->transUnit->contxt.EnterScope();
            gProject->Parse_TOS->parseCtxt->PushCtxt();
        ;
    break;}
case 326:
#line 2166 "gram.y"
{
            gProject->Parse_TOS->parseCtxt->PopCtxt(true);
            gProject->Parse_TOS->parseCtxt->IncrVarParam(-1);
            yyval.decl = yyvsp[0].decl ;
        ;
    break;}
case 328:
#line 2175 "gram.y"
{
            BaseType *bt = new BaseType(BT_Ellipsis);

            yyval.decl = new Decl(bt);
            yyval.decl->next = yyvsp[-2].decl;
        ;
    break;}
case 330:
#line 2185 "gram.y"
{
            yyval.decl = yyvsp[0].decl;
            yyval.decl->next = yyvsp[-2].decl;
        ;
    break;}
case 331:
#line 2192 "gram.y"
{   
            gProject->Parse_TOS->parseCtxt->PushCtxt();
        ;
    break;}
case 332:
#line 2196 "gram.y"
{
            gProject->Parse_TOS->parseCtxt->PopCtxt(true);
            yyval.decl = yyvsp[0].decl;
        ;
    break;}
case 333:
#line 2203 "gram.y"
{
            assert (gProject->Parse_TOS->err_top_level ||
                    yyvsp[-1].base == gProject->Parse_TOS->parseCtxt->curCtxt->decl_specs);
            gProject->Parse_TOS->possibleType = true;
            yyval.decl = yyvsp[0].decl;
            Type * decl = gProject->Parse_TOS->parseCtxt->UseDeclCtxt();
            Type * extended = yyval.decl->extend(decl);             
            if (yyval.decl->form &&
                yyval.decl->form->isFunction())
             {
                if(yyerr ("Function type not allowed"))
                  YYERROR;
             }
            else if (extended && 
                decl && decl->isFunction() && 
                ! extended->isPointer())
             {
                if(yyerr ("Wrong type combination"))
                  YYERROR;
             }
        ;
    break;}
case 334:
#line 2225 "gram.y"
{
            assert (gProject->Parse_TOS->err_top_level ||
                    yyvsp[-1].base == gProject->Parse_TOS->parseCtxt->curCtxt->decl_specs);
            gProject->Parse_TOS->possibleType = true;
            yyval.decl = new Decl(yyvsp[0].type);
            
            Type * decl = gProject->Parse_TOS->parseCtxt->UseDeclCtxt();
            Type * extended = yyval.decl->extend(decl);
            if (yyval.decl->form &&
                yyval.decl->form->isFunction())
            {
                if(yyerr ("Function type not allowed for parameter"))
                  YYERROR;
            }
            else if (extended && 
                decl && decl->isFunction() && 
                ! extended->isPointer())
            {
                if(yyerr ("Wrong type combination"))
                  YYERROR;
            }
        ;
    break;}
case 335:
#line 2248 "gram.y"
{
            gProject->Parse_TOS->possibleType = true;
            yyval.decl = new Decl(yyvsp[0].base);
            if (yyval.decl->form &&
                yyval.decl->form->isFunction())
                if(yyerr ("Function type not allowed for parameter"))
                  YYERROR;
        ;
    break;}
case 336:
#line 2262 "gram.y"
{
            yyval.type = yyvsp[0].ptr;
        ;
    break;}
case 337:
#line 2266 "gram.y"
{
            yyval.type = yyvsp[0].type;
        ;
    break;}
case 338:
#line 2270 "gram.y"
{
            yyval.type = yyvsp[0].type;
            yyval.type->extend(yyvsp[-1].ptr);
        ;
    break;}
case 340:
#line 2280 "gram.y"
{
            yyval.type = yyvsp[-1].type;
        ;
    break;}
case 341:
#line 2284 "gram.y"
{
            yyval.type = new ArrayType(yyvsp[-1].value);
        ;
    break;}
case 342:
#line 2288 "gram.y"
{
            ArrayType *at = new ArrayType(yyvsp[-1].value);
            yyval.type = yyvsp[-3].type;
            yyval.type->extend(at);
            Type * extended = yyval.type->extend(at) ;
            if (extended && 
                extended->isFunction())
                if(yyerr ("Wrong type combination"))
                  YYERROR;
        ;
    break;}
case 343:
#line 2299 "gram.y"
{
            yyval.type = new FunctionType(ReverseList(yyvsp[-1].decl));
        ;
    break;}
case 344:
#line 2303 "gram.y"
{
            FunctionType * ft = new FunctionType(ReverseList(yyvsp[-1].decl));
            yyval.type = yyvsp[-3].type;
            Type * extended = yyval.type->extend(ft) ;
            if (extended && 
                ! extended->isPointer())
                if(yyerr ("Wrong type combination"))
                  YYERROR;
                
        ;
    break;}
case 345:
#line 2320 "gram.y"
{
            yyval.gccAttrib = (GccAttrib*) NULL;
        ;
    break;}
case 347:
#line 2327 "gram.y"
{
                yyval.gccAttrib = yyvsp[-2].gccAttrib;
                delete yyvsp[-4].loc;
                delete yyvsp[-3].loc;
                delete yyvsp[-1].loc;
                delete yyvsp[0].loc;
            ;
    break;}
case 348:
#line 2337 "gram.y"
{
                /* The lexer ate some unsupported option. */
                yyval.gccAttrib = new GccAttrib( GCC_Unsupported);
            ;
    break;}
case 349:
#line 2342 "gram.y"
{
                yyval.gccAttrib = new GccAttrib( GCC_Packed );
            ;
    break;}
case 350:
#line 2346 "gram.y"
{
                yyval.gccAttrib = new GccAttrib( GCC_CDecl );
            ;
    break;}
case 351:
#line 2350 "gram.y"
{
                yyval.gccAttrib = new GccAttrib( GCC_Const );
            ;
    break;}
case 352:
#line 2354 "gram.y"
{
                yyval.gccAttrib = new GccAttrib( GCC_NoReturn );
            ;
    break;}
case 353:
#line 2358 "gram.y"
{
                yyval.gccAttrib = new GccAttrib( GCC_Aligned );

                if (yyvsp[-1].consValue->ctype == CT_Int)
                {
                    IntConstant    *iCons = (IntConstant*) yyvsp[-1].consValue;

                    yyval.gccAttrib->value = iCons->lng;
                }

                delete yyvsp[-2].loc;
                delete yyvsp[0].loc;
            ;
    break;}
case 354:
#line 2372 "gram.y"
{
                yyval.gccAttrib = new GccAttrib( GCC_Mode );

                yyval.gccAttrib->mode = yyvsp[-1].symbol;

                delete yyvsp[-2].loc;
                delete yyvsp[0].loc;
            ;
    break;}
case 355:
#line 2381 "gram.y"
{
                yyval.gccAttrib = new GccAttrib( GCC_Format );
    
                yyval.gccAttrib->mode = yyvsp[-5].symbol;

                if (yyvsp[-3].consValue->ctype == CT_Int)
                {
                    IntConstant    *iCons = (IntConstant*) yyvsp[-3].consValue;

                    yyval.gccAttrib->strIdx = iCons->lng;
                }

                if (yyvsp[-1].consValue->ctype == CT_Int)
                {
                    IntConstant    *iCons = (IntConstant*) yyvsp[-1].consValue;

                    yyval.gccAttrib->first = iCons->lng;
                }

                delete yyvsp[-6].loc;
                delete yyvsp[0].loc;
            ;
    break;}
case 356:
#line 2404 "gram.y"
{
                yyval.gccAttrib = new GccAttrib( GCC_Malloc );
            ;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */
#line 498 "/usr/lib/bison.simple"

  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YYLSP_NEEDED
  yylsp -= yylen;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++yyvsp = yyval;

#ifdef YYLSP_NEEDED
  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = yylloc.first_line;
      yylsp->first_column = yylloc.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  goto yynewstate;

yyerrlab:   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++yynerrs;

#ifdef YYERROR_VERBOSE
      yyn = yypact[yystate];

      if (yyn > YYFLAG && yyn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
	  for (x = (yyn < 0 ? -yyn : 0);
	       x < (sizeof(yytname) / sizeof(char *)); x++)
	    if (yycheck[x + yyn] == x)
	      size += strlen(yytname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (yyn < 0 ? -yyn : 0);
		       x < (sizeof(yytname) / sizeof(char *)); x++)
		    if (yycheck[x + yyn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, yytname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      yyerror(msg);
	      free(msg);
	    }
	  else
	    yyerror ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YYERROR_VERBOSE */
	yyerror("parse error");
    }

  goto yyerrlab1;
yyerrlab1:   /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (yychar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
#endif

      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto yyerrhandle;

yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) goto yydefault;
#endif

yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YYLSP_NEEDED
  yylsp--;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yyerrdefault;

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  yystate = yyn;
  goto yynewstate;
}
#line 2409 "gram.y"


/*******************************************************/
